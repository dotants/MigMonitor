<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Table + Diagram with Minimap</title>
    <style>
      /* Global styles */
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background-color: #f4f4f9;
      }
      .container {
        display: flex;
        flex-direction: row;
        height: 100vh;
        min-height: 100vh;
      }
      .table-container,
      .diagram-container {
        flex: 1;
        padding: 20px;
        box-sizing: border-box;
        position: relative;
      }
      .table-container {
        overflow-y: auto;
      }
      /* Diagram container with fixed size and no scrollbars – panning is via mouse drag */
      .diagram-container {
        overflow: hidden;
        min-height: 600px;
      }
      /* Center Diagram Button */
      .center-btn {
        position: absolute;
        top: 12px;
        right: 58px;
        z-index: 1100;
        padding: 5px 10px;
        background-color: #1483f3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      /* Reset Diagram Button */
      .reset-btn {
        position: absolute;
        top: 12px;
        right: 20px;
        z-index: 1100;
        padding: 5px 10px;
        background-color: #1483f3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      /* Zoom controls container */
      .zoom-controls-container {
        position: absolute;
        top: 217px;
        right: 20px;
        display: flex;
        flex-direction: row;
        align-items: center;
        z-index: 1200;
      }
      /* Zoom percentage display */
      .zoom-percentage {
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 14px;
        margin-right: 10px;
        margin-left: 10px;
      }
      /* Zoom buttons */
      .zoom-btn {
        padding: 5px 10px;
        background-color: #1483f3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-left: 1px;
      }
      /* Drag hint overlay (optional) */
      .drag-hint {
        position: absolute;
        top: 210px;
        right: -17px;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 1100;
        font-size: 12px;
      }
      /* Minimap container */
      .minimap-container {
        position: absolute;
        top: 50px;
        right: 10px;
        z-index: 1200;
        width: 200px;
        height: 150px;
        border: 1px solid #ccc;
        background-color: #fff;
      }
      /* Table styling */
      #loading,
      #error-message {
        font-size: 18px;
        margin-bottom: 20px;
      }
      #loading {
        color: #333;
      }
      #error-message {
        color: #e74c3c;
        display: none;
      }
      h3 {
        color: #1483f3;
        font-size: 22px;
        margin-bottom: 15px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        background-color: #fff;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        table-layout: fixed;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
        white-space: nowrap;
        font-size: 13px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      th:first-child,
      td:first-child {
        width: 35%;
        position: relative;
      }
      th:not(:first-child),
      td:not(:first-child) {
        width: 16.25%;
        text-align: right;
        padding-right: 20px;
      }
      th {
        background-color: #1483f3;
        color: white;
        font-weight: bold;
      }
      tr:nth-child(even) {
        background-color: #f2f2f2;
      }
      tr:hover {
        background-color: #ddd;
      }
      .sub-header {
        background-color: #3382d1;
        color: #fff;
        font-weight: bold;
        border-top: 2px solid #000000 !important;
        border-left: 2px solid #000000 !important;
        border-right: 2px solid #000000 !important;
      }
      .sub-header th {
        border-top: 0px solid #000000 !important;
        border-bottom: 0px solid #000000 !important;
      }
      .spacer-row td {
        border: none;
      }
      .main-row {
        cursor: pointer;
      }
      /* Expandable row styling */
      .main-row.expandable td:first-child {
        position: relative;
        padding-left: 20px;
      }
      .main-row.expandable td:first-child::before {
        content: "▶";
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        transition: transform 0.2s;
        cursor: pointer;
      }
      .main-row.expandable.expanded td:first-child::before {
        transform: translateY(-50%) rotate(90deg);
      }
      /* Selected main row styling */
      .main-row.selected td {
        border-top: 0px solid #000000 !important;
        border-bottom: 0px solid #000000 !important;
        border-left: none !important;
        border-right: none !important;
      }
      .main-row.selected td:first-child {
        border-left: 0px solid #000000 !important;
      }
      .main-row.selected td:last-child {
        border-right: 0px solid #000000 !important;
      }
      /* Sub-process row styling */
      .sub-process td {
        border-top: 0px solid #000000 !important;
        border-bottom: 0px solid #000000 !important;
        border-left: none !important;
        border-right: none !important;
      }
      .sub-process td:first-child {
        border-left: 2px solid #000000 !important;
        padding-left: 25px;
      }
      .sub-process td:last-child {
        border-right: 2px solid #000000 !important;
      }
      .sub-process:last-of-type td {
        border-bottom: 2px solid #000000 !important;
      }
      .hierarchy-indicator {
        display: inline-block;
        width: 16px;
        height: 16px;
        text-align: center;
        line-height: 16px;
        margin-right: 8px;
      }
      .indent-level-1 {
        padding-left: 25px !important;
      }
      .indent-level-2 {
        padding-left: 45px !important;
      }
      /* Diagram styling */
      #diagram {
        width: 100%;
        height: 100%;
        display: block;
      }
      .node rect {
        fill: #1483f3;
        stroke-width: 4;
        cursor: pointer;
      }
      .node text {
        fill: #ffffff;
        font-size: 12px;
        pointer-events: none;
      }
      .edge {
        stroke: #555;
        stroke-width: 2;
        marker-end: url(#arrow);
      }
      /* Status indicator styling */
      .status-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 5px;
      }
      .status-completed {
        background-color: #2ecc71;
      }
      .status-in-progress {
        background-color: #2ecc71;
        border: 1px dashed #27ae60;
      }
      .status-pending {
        background-color: #ffffff;
        border: 1px solid #cccccc;
      }
      .status-rejected {
        background-color: #e74c3c;
      }
      .status-na {
        background-color: #000000;
      }
      .status-default {
        background-color: #808080;
      }
      /* Tooltip styling */
      .tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 1000;
      }
      /* Update Notification Bubble styling */
      .update-notification {
        font-size: 12px;
        background-color: yellow;
        color: black;
        padding: 5px 10px;
        border-radius: 5px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
      }
      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
        .table-container,
        .diagram-container {
          height: auto;
          width: 100%;
        }
      }
      /* Spinner styling for loading indication */
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border-left-color: #1483f3;
        display: inline-block;
        margin-right: 10px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      /* Styles for the new subrows container */
      .subrows-container {
        background-color: #e9e9ff; /* Example background */
      }
      .subrows-wrapper {
        padding: 10px;
        border: 1px solid #ccc;
        overflow-x: auto;
      }
      .subrows-table {
        width: 100%;
        border-collapse: collapse;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Table Section -->
      <div class="table-container">
        <div id="loading">
          <span class="spinner"></span> Loading data, please wait...
        </div>
        <div id="error-message">
          Error loading data. Please try again or contact support.
        </div>
        <h3 id="Exec_ID">Run Number: 0</h3>
        <table id="sfTable" style="display: none">
          <thead>
            <tr>
              <th>Name</th>
              <th>Completed</th>
              <th>Rejected</th>
              <th>In Process</th>
              <th>Pending</th>
            </tr>
          </thead>
          <tbody>
            <!-- Dynamic rows will be inserted here -->
          </tbody>
        </table>
      </div>
      <!-- Diagram Section -->
      <div class="diagram-container">
        <!-- Center Diagram Button -->
        <button class="center-btn" id="centerBtn">Center Diagram</button>
        <!-- Reset Diagram Button -->
        <button class="reset-btn" id="resetBtn">↺</button>
        <!-- Zoom Controls -->
        <div class="zoom-controls-container">
          <button id="zoomOutBtn" class="zoom-btn">–</button>
          <div id="zoomPercentage" class="zoom-percentage">100%</div>
          <button id="zoomInBtn" class="zoom-btn">+</button>
        </div>
        <!-- (Optional) Drag Hint Overlay -->
        <!-- <div class="drag-hint">Drag to pan diagram</div> -->
        <!-- Main SVG Diagram -->
        <svg
          id="diagram"
          viewBox="30 30 800 600"
          preserveAspectRatio="xMidYMid meet"
          style="width: 100%; height: 100%"
        ></svg>
        <!-- Tooltip for diagram nodes -->
        <div class="tooltip" id="diagram-tooltip"></div>
        <!-- Minimap Container -->
        <div class="minimap-container">
          <svg
            id="minimap"
            viewBox="0 0 400 300"
            style="width: 100%; height: 100%"
          ></svg>
          <rect
            id="minimap-viewport"
            x="0"
            y="0"
            width="200"
            height="150"
            fill="none"
            stroke="red"
            stroke-width="2"
          ></rect>
        </div>
      </div>
    </div>
    <!-- k2api configuration and navigation setup -->
    <script>
      window.onload = function () {
        window.k2api = window.k2api || window.parent.k2api;
        if (!window.k2api) {
          window.k2api = {
            setNavigationMenu: function () {},
            invokeFabricWebService: async function (apiName, params, method) {
              console.log("Mock call:", apiName, params, method);
              return Promise.resolve({});
            },
          };
        }
        window.k2api.setNavigationMenu([{ name: "Main", path: "/index.html" }]);
        DataManager.init();
      };
    </script>
    <!-- Utility Functions Module -->
    <script>
      const Utils = {
        safeJsonParse: function (str, fallback) {
          try {
            return JSON.parse(str);
          } catch (e) {
            console.error("Error parsing JSON:", e);
            return fallback;
          }
        },
        showError: function (message, error) {
          const errorElement = document.getElementById("error-message");
          if (errorElement) {
            errorElement.textContent = message;
            errorElement.style.display = "block";
            document.getElementById("loading").style.display = "none";
          }
          console.error(message, error);
        },
        hideError: function () {
          const errorElement = document.getElementById("error-message");
          if (errorElement) {
            errorElement.style.display = "none";
          }
        },
        debounce: function (func, wait) {
          let timeout;
          return function (...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        },
      };
    </script>
    <!-- Data Manager Module -->
    <script>
      const DataManager = {
        steps: [],
        responses: {},
        execId: 0,
        init: async function () {
          try {
            Utils.hideError();
            await this.loadData();
            TableView.init();
            DiagramView.init();
            this.setupRefreshIntervals();
          } catch (error) {
            Utils.showError("Failed to initialize the application", error);
          }
        },
        loadData: async function () {
          try {
            Utils.hideError();
            let execId;
            try {
              const wsExecIdResponse = await k2api.invokeFabricWebService(
                "wsExecId",
                { token: "", format: "json" },
                "GET"
              );
              execId =
                wsExecIdResponse?.execId ||
                (typeof wsExecIdResponse === "object"
                  ? Object.values(wsExecIdResponse)[0]
                  : wsExecIdResponse);
              if (!execId) throw new Error("Could not extract execution ID");
            } catch (execError) {
              console.error("Execution ID fetch failed:", execError);
              execId = Date.now();
            }
            this.execId = execId;
            document.getElementById("Exec_ID").innerHTML =
              "Run Number: " + this.execId;
            let steps;
            try {
              steps = await k2api.invokeFabricWebService(
                "wsMonitorConfig",
                { token: "", format: "json" },
                "GET"
              );
              steps = Array.isArray(steps)
                ? steps
                : typeof steps === "object"
                ? Object.values(steps)
                : [];
            } catch (configError) {
              console.error("Steps configuration fetch failed:", configError);
              steps = [];
            }
            if (steps.length === 0)
              throw new Error("No steps found in configuration");
            this.steps = steps;
            this.responses = await this.fetchAllApiResponses(this.steps);
            console.log("Loaded API responses:", this.responses);
            document.getElementById("loading").style.display = "none";
            document.getElementById("sfTable").style.display = "table";
            TableView.init();
          } catch (error) {
            Utils.showError("Failed to load initial data", error);
            document.getElementById("loading").style.display = "none";
            document.getElementById("sfTable").style.display = "table";
          }
        },
        fetchAllApiResponses: async function (steps) {
          const responses = {};
          const tasks = [];
          steps.forEach((step) => {
            if (step["API Name"]) {
              tasks.push(
                this.fetchApiResponse(step["API Name"])
                  .then((response) => {
                    responses[step["API Name"]] = response;
                  })
                  .catch((error) => {
                    console.error(
                      `Error fetching data for ${step["API Name"]}:`,
                      error
                    );
                  })
              );
            }
          });
          await Promise.allSettled(tasks);
          return responses;
        },
        fetchApiResponse: async function (apiName) {
          try {
            const response = await k2api.invokeFabricWebService(
              apiName,
              { token: "", execId: this.execId },
              "GET"
            );
            console.log(`Response from ${apiName}:`, response);
            if (typeof response === "object" && response !== null) {
              console.log(`Response structure for ${apiName}:`);
              this.logObjectStructure(response);
            }
            return response;
          } catch (error) {
            console.error(`Error fetching API ${apiName}:`, error);
            throw error;
          }
        },
        logObjectStructure: function (obj, depth = 0, maxDepth = 2) {
          if (depth > maxDepth) {
            console.log("  ".repeat(depth) + "[Max depth reached]");
            return;
          }
          if (Array.isArray(obj)) {
            console.log(
              "  ".repeat(depth) + "Array with " + obj.length + " items"
            );
            if (obj.length > 0) {
              console.log("  ".repeat(depth) + "First item:");
              this.logObjectStructure(obj[0], depth + 1, maxDepth);
            }
          } else if (typeof obj === "object" && obj !== null) {
            const keys = Object.keys(obj);
            console.log(
              "  ".repeat(depth) + "Object with " + keys.length + " keys"
            );
            for (const key of keys) {
              const value = obj[key];
              const valueType = typeof value;
              if (valueType === "object" && value !== null) {
                console.log(
                  "  ".repeat(depth) +
                    key +
                    ": [" +
                    (Array.isArray(value) ? "Array" : "Object") +
                    "]"
                );
                this.logObjectStructure(value, depth + 1, maxDepth);
              } else {
                const strValue =
                  valueType === "string"
                    ? value.length > 50
                      ? value.substring(0, 47) + "..."
                      : value
                    : String(value);
                console.log(
                  "  ".repeat(depth) +
                    key +
                    ": " +
                    valueType +
                    " (" +
                    strValue +
                    ")"
                );
              }
            }
          } else {
            console.log("  ".repeat(depth) + "Value: " + String(obj));
          }
        },
        refreshAllData: async function () {
          console.log("Performing full data refresh...");
          try {
            const updatedResponses = await this.fetchAllApiResponses(
              this.steps
            );
            this.responses = updatedResponses;
            // Instead of rebuilding the table entirely, update all rows
            TableView.updateAllRows();
            DiagramView.update();
            console.log("Full data refresh complete");
          } catch (error) {
            console.error("Error during full data refresh:", error);
          }
        },
        setupRefreshIntervals: function () {
          const EXEC_ID_REFRESH_INTERVAL = 15000;
          setInterval(async () => {
            try {
              console.log("Refreshing execution ID...");
              let execId;
              try {
                const wsExecIdResponse = await k2api.invokeFabricWebService(
                  "wsExecId",
                  { token: "", format: "json" },
                  "GET"
                );
                execId =
                  wsExecIdResponse?.execId ||
                  (typeof wsExecIdResponse === "object"
                    ? Object.values(wsExecIdResponse)[0]
                    : wsExecIdResponse);
                if (!execId) throw new Error("Could not extract execution ID");
              } catch (execError) {
                console.error("Execution ID fetch failed:", execError);
                execId = Date.now();
              }
              this.execId = execId;
              document.getElementById("Exec_ID").innerHTML =
                "Run Number: " + this.execId;
              console.log("Execution ID refresh complete: " + this.execId);
            } catch (error) {
              console.error("Error during execution ID refresh:", error);
            }
          }, EXEC_ID_REFRESH_INTERVAL);
          const MASTER_REFRESH_INTERVAL = 30000;
          setInterval(() => {
            this.refreshAllData();
          }, MASTER_REFRESH_INTERVAL);
          this.steps.forEach((step) => {
            if (step["API Name"] && step["Refresh interval"]) {
              const interval = parseInt(step["Refresh interval"], 10) * 1000;
              if (isNaN(interval) || interval <= 0) return;
              setInterval(async () => {
                try {
                  console.log(`Refreshing API: ${step["API Name"]}`);
                  const updatedResponse = await this.fetchApiResponse(
                    step["API Name"]
                  );
                  this.responses[step["API Name"]] = updatedResponse;
                  TableView.updateTableRowForStep(step, updatedResponse);
                  DiagramView.update();
                  console.log(`API refresh complete: ${step["API Name"]}`);
                } catch (error) {
                  console.error(
                    `Error in refresh interval for ${step["API Name"]}:`,
                    error
                  );
                }
              }, interval);
            }
          });
        },
        getGroupedSteps: function () {
          const mainSteps = this.steps.filter((step) => step.Type === "MAIN");
          const subSteps = this.steps.filter((step) => step.Type === "SUB");
          mainSteps.forEach((main) => {
            const mainNum = main["Step Number"];
            main.subSteps = subSteps.filter((sub) => {
              if (!sub["Parent Steps"]) return false;
              const parents = sub["Parent Steps"]
                .split(",")
                .map((s) => s.trim());
              return parents.includes(mainNum);
            });
          });
          return mainSteps;
        },
        parseStatus: function (response) {
          try {
            if (!response) return null;
            let data = response;
            if (Array.isArray(data)) {
              data = data.length > 0 ? data[0] : null;
              if (Array.isArray(data)) {
                data = data.length > 0 ? data[0] : null;
              }
            }
            if (!data) return null;
            let statusString = null;
            if (typeof data === "object") {
              for (const key in data) {
                if (
                  data[key] &&
                  typeof data[key] === "string" &&
                  (data[key].includes("status=") ||
                    data[key].includes('"status":'))
                ) {
                  statusString = data[key];
                  console.log(
                    `Found status string in property '${key}'`,
                    statusString.substring(0, 50) + "..."
                  );
                  break;
                }
              }
            } else if (typeof data === "string") {
              statusString = data;
            }
            if (!statusString) {
              console.warn("No status string found in response");
              return null;
            }
            let status = "unknown";
            const statusMatch = statusString.match(/status=([^,}]+)/);
            if (statusMatch) {
              status = statusMatch[1].trim();
              console.log("Extracted status:", status);
            }
            const result = {
              status: status,
              name: "",
              completed: "0",
              rejected: "0",
              inProcess: "0",
              pending: "0",
              subProcesses: [],
            };
            const nameMatch = statusString.match(/name=([^,}]+)/);
            if (nameMatch) {
              result.name = nameMatch[1].trim();
            }
            const completedMatch = statusString.match(/completed=([^,}]+)/);
            if (completedMatch) {
              result.completed = completedMatch[1].trim();
            }
            const rejectedMatch = statusString.match(/rejected=([^,}]+)/);
            if (rejectedMatch) {
              result.rejected = rejectedMatch[1].trim();
            }
            const inProcessMatch = statusString.match(/in process=([^,}]+)/);
            if (inProcessMatch) {
              result.inProcess = inProcessMatch[1].trim();
            }
            const pendingMatch = statusString.match(/pending=([^,}]+)/);
            if (pendingMatch) {
              result.pending = pendingMatch[1].trim();
            }
            console.log("Extracting subProcesses from status string...");
            const subProcessPart = statusString.match(/subProcesses=\[(.*)\]/s);
            if (subProcessPart && subProcessPart[1]) {
              console.log(
                "Found subProcesses section:",
                subProcessPart[1].substring(0, 50) + "..."
              );
              const subProcessRegex =
                /\{name=([^,]+), status=([^,]+), completed=([^,]+), rejected=([^,]+), in process=([^,]+), pending=([^,}]+)\}/g;
              let match;
              while (
                (match = subProcessRegex.exec(subProcessPart[1])) !== null
              ) {
                console.log("Found subprocess via regex:", match[1]);
                result.subProcesses.push({
                  name: match[1].trim(),
                  status: match[2].trim(),
                  completed: match[3].trim(),
                  rejected: match[4].trim(),
                  inProcess: match[5].trim(),
                  pending: match[6].trim(),
                });
              }
              if (result.subProcesses.length === 0) {
                console.log(
                  "Primary regex failed, attempting manual parsing of subprocesses"
                );
                const items = subProcessPart[1].split("}, {");
                console.log(
                  `Found ${items.length} subprocesses by manual splitting`
                );
                for (let item of items) {
                  if (!item.startsWith("{")) {
                    item = "{" + item;
                  }
                  if (!item.endsWith("}")) {
                    item = item + "}";
                  }
                  console.log("Processing subprocess item:", item);
                  const nameMatch = item.match(/name=([^,]+)/);
                  const statusMatch = item.match(/status=([^,]+)/);
                  const completedMatch = item.match(/completed=([^,]+)/);
                  const rejectedMatch = item.match(/rejected=([^,]+)/);
                  const inProcessMatch = item.match(/in process=([^,]+)/);
                  const pendingMatch = item.match(/pending=([^,}]+)/);
                  if (nameMatch) {
                    console.log(
                      "Found subprocess via manual parsing:",
                      nameMatch[1]
                    );
                    result.subProcesses.push({
                      name: nameMatch[1].trim(),
                      status: statusMatch ? statusMatch[1].trim() : "unknown",
                      completed: completedMatch
                        ? completedMatch[1].trim()
                        : "0",
                      rejected: rejectedMatch ? rejectedMatch[1].trim() : "0",
                      inProcess: inProcessMatch
                        ? inProcessMatch[1].trim()
                        : "0",
                      pending: pendingMatch ? pendingMatch[1].trim() : "0",
                    });
                  }
                }
              }
            }
            console.log("Final parsed result with subProcesses:", result);
            console.log(
              `Found ${result.subProcesses.length} subprocesses in total`
            );
            return result;
          } catch (error) {
            console.error("Error parsing status:", error);
            return null;
          }
        },
        getStepByNumber: function (stepNumber) {
          return (
            this.steps.find((step) => step["Step Number"] === stepNumber) ||
            null
          );
        },
      };
    </script>
    <!-- Table View Module -->
    <script>
      const TableView = {
        expandedRows: new Set(),
        init: function () {
          this.buildTable(DataManager.getGroupedSteps(), DataManager.responses);
          window.addEventListener(
            "resize",
            Utils.debounce(() => {
              this.adjustTableWidth();
            }, 200)
          );
          this.adjustTableWidth();
        },
        adjustTableWidth: function () {
          const table = document.getElementById("sfTable");
          if (!table) return;
          const containerWidth = table.parentElement.clientWidth;
        },
        buildTable: function (groupedSteps, responses) {
          const tableBody = document.querySelector("#sfTable tbody");
          tableBody.innerHTML = "";
          for (
            let mainRowCounter = 0;
            mainRowCounter < groupedSteps.length;
            mainRowCounter++
          ) {
            const main = groupedSteps[mainRowCounter];
            let parsedMain = null;
            if (main["API Name"] && responses[main["API Name"]]) {
              let resp = responses[main["API Name"]];
              parsedMain = DataManager.parseStatus(resp);
              console.log(`Parsed data for ${main["Step Name"]}:`, parsedMain);
            }
            if (!parsedMain) {
              parsedMain = {
                name: main["Step Name"] || "Unknown Step",
                status: "unknown",
                completed: "0",
                rejected: "0",
                inProcess: "0",
                pending: "0",
                subProcesses: [],
              };
            }
            const mainRow = document.createElement("tr");
            mainRow.setAttribute("data-step-number", main["Step Number"]);
            mainRow.classList.add("main-row");
            if (main.subSteps && main.subSteps.length > 0) {
              mainRow.classList.add("expandable");
              if (this.expandedRows.has(mainRowCounter.toString())) {
                mainRow.classList.add("expanded");
              }
            }
            mainRow.setAttribute("data-main-row-id", mainRowCounter);
            if (main["API Name"]) {
              mainRow.setAttribute("data-api-name", main["API Name"]);
            }
            mainRow.groupedSubSteps = main.subSteps || [];
            mainRow.oldParsedData = parsedMain;
            const statusClass = this.getStatusClass(parsedMain);
            const nameCell = document.createElement("td");
            const statusSpan = document.createElement("span");
            statusSpan.className = `status-indicator ${statusClass}`;
            nameCell.appendChild(statusSpan);
            const nameStrong = document.createElement("strong");
            nameStrong.textContent = parsedMain.name;
            nameCell.appendChild(nameStrong);
            mainRow.appendChild(nameCell);
            const completedCell = document.createElement("td");
            completedCell.textContent = parsedMain.completed;
            mainRow.appendChild(completedCell);
            const rejectedCell = document.createElement("td");
            rejectedCell.textContent = parsedMain.rejected;
            mainRow.appendChild(rejectedCell);
            const inProcessCell = document.createElement("td");
            inProcessCell.textContent = parsedMain.inProcess;
            mainRow.appendChild(inProcessCell);
            const pendingCell = document.createElement("td");
            pendingCell.textContent = parsedMain.pending;
            mainRow.appendChild(pendingCell);
            if (main.subSteps && main.subSteps.length > 0) {
              mainRow.addEventListener("click", (e) => {
                const id = mainRow.getAttribute("data-main-row-id");
                this.toggleRowExpansion(id, mainRow);
                this.toggleSelectedRow(mainRow);
              });
            } else {
              mainRow.addEventListener("click", () => {
                this.toggleSelectedRow(mainRow);
              });
            }
            tableBody.appendChild(mainRow);
            if (main.subSteps && main.subSteps.length > 0) {
              // Call the new addSubRows function to add the subrows container
              this.addSubRows(tableBody, main, parsedMain, mainRowCounter);
            }
          }
        },
        getStatusClass: function (data) {
          if (!data || !data.status) return "status-default";
          const status = data.status.toLowerCase();
          if (status === "n/a") return "status-na";
          if (status === "failed" || status === "rejected")
            return "status-rejected";
          if (status === "running" || status === "in process")
            return "status-in-progress";
          if (status === "completed") return "status-completed";
          if (status === "pending") return "status-pending";
          return "status-default";
        },
        /* Updated addSubRows function that wraps sub-rows in a container row and cell. */
        addSubRows: function (tableBody, main, parsedMain, mainRowCounter) {
          console.log(
            `Adding sub-rows for ${main["Step Name"]} with ${
              parsedMain.subProcesses ? parsedMain.subProcesses.length : 0
            } subProcesses`
          );
          const isExpanded = this.expandedRows.has(mainRowCounter.toString());
          // Get the main row element by its data-main-row-id attribute
          const mainRow = tableBody.querySelector(
            `tr[data-main-row-id="${mainRowCounter}"]`
          );
          if (!mainRow) return;

          // Create a new table row to serve as the container for all sub-rows.
          const containerRow = document.createElement("tr");
          containerRow.classList.add("subrows-container");
          // Set a data attribute to associate this container with the main row
          containerRow.setAttribute("data-parent-id", mainRowCounter);
          // Show or hide the container row based on whether the main row is expanded
          containerRow.style.display = isExpanded ? "table-row" : "none";

          // Create a table cell that spans all columns (5 columns in this case)
          const containerCell = document.createElement("td");
          containerCell.setAttribute("colspan", "5");

          // Create a div wrapper for custom styling of sub-rows
          const wrapperDiv = document.createElement("div");
          wrapperDiv.classList.add("subrows-wrapper");

          // Create an inner table to display sub-header and sub-rows in a table layout
          const innerTable = document.createElement("table");
          innerTable.classList.add("subrows-table");

          // Create the sub-header for the inner table
          const subHeader = document.createElement("thead");
          const headerRow = document.createElement("tr");
          headerRow.classList.add("sub-header");
          headerRow.innerHTML = `
            <th>Name</th>
            <th>Completed</th>
            <th>Rejected</th>
            <th>In Process</th>
            <th>Pending</th>
          `;
          subHeader.appendChild(headerRow);
          innerTable.appendChild(subHeader);

          // Create tbody for the inner table where sub-rows will be added
          const innerTbody = document.createElement("tbody");

          // Loop through each sub-step of the main process
          main.subSteps.forEach((sub) => {
            let parsedSub = null;
            if (sub["API Name"] && DataManager.responses[sub["API Name"]]) {
              let resp = DataManager.responses[sub["API Name"]];
              parsedSub = DataManager.parseStatus(resp);
              console.log(
                `Found direct data for subprocess ${sub["Step Name"]}:`,
                parsedSub
              );
            }
            if (
              !parsedSub &&
              parsedMain.subProcesses &&
              parsedMain.subProcesses.length > 0
            ) {
              parsedSub = parsedMain.subProcesses.find(
                (item) =>
                  item.name.toLowerCase() === sub["Step Name"].toLowerCase()
              );
              if (parsedSub) {
                console.log(
                  `Found subprocess ${sub["Step Name"]} in parent's subProcesses array:`,
                  parsedSub
                );
              }
            }
            if (!parsedSub) {
              console.log(
                `No data found for subprocess ${sub["Step Name"]}, using defaults`
              );
              parsedSub = {
                name: sub["Step Name"],
                status: "unknown",
                completed: "0",
                rejected: "0",
                inProcess: "0",
                pending: "0",
              };
            }

            const statusClass = this.getStatusClass(parsedSub);
            const subRow = document.createElement("tr");
            subRow.classList.add("sub-process");
            if (sub["API Name"]) {
              subRow.setAttribute("data-api-name", sub["API Name"]);
            }
            // Create cells for each column in the sub-row
            const nameCell = document.createElement("td");
            const nameContainer = document.createElement("div");
            nameContainer.className = "cell-container";
            const verticalLine = document.createElement("span");
            verticalLine.style.display = "inline-block";
            verticalLine.style.width = "3px";
            verticalLine.style.height = "14px";
            verticalLine.style.backgroundColor = "#1483f3";
            verticalLine.style.marginRight = "6px";
            verticalLine.style.flexShrink = "0";
            nameContainer.appendChild(verticalLine);
            const statusSpan = document.createElement("span");
            statusSpan.className = `status-indicator ${statusClass}`;
            statusSpan.style.flexShrink = "0";
            statusSpan.style.marginRight = "6px";
            nameContainer.appendChild(statusSpan);
            const nameSpan = document.createElement("span");
            nameSpan.className = "name-container";
            nameSpan.textContent = parsedSub.name;
            nameContainer.appendChild(nameSpan);
            nameCell.appendChild(nameContainer);
            const completedCell = document.createElement("td");
            completedCell.textContent = parsedSub.completed;
            // Uncomment the following line to add a border to the completed cell
            //completedCell.style.borderBottom = "2px solid #000000";
            const rejectedCell = document.createElement("td");
            rejectedCell.textContent = parsedSub.rejected;
            const inProcessCell = document.createElement("td");
            inProcessCell.textContent = parsedSub.inProcess;
            const pendingCell = document.createElement("td");
            pendingCell.textContent = parsedSub.pending;

            // Append all cells to the sub-row
            subRow.appendChild(nameCell);
            subRow.appendChild(completedCell);
            subRow.appendChild(rejectedCell);
            subRow.appendChild(inProcessCell);
            subRow.appendChild(pendingCell);

            // Add click event for row selection
            subRow.addEventListener("click", (e) => {
              e.stopPropagation();
              this.toggleSelectedRow(subRow);
            });

            // Append the sub-row to the inner table body
            innerTbody.appendChild(subRow);
          });

          // Assemble the inner table and wrapper
          innerTable.appendChild(innerTbody);
          wrapperDiv.appendChild(innerTable);
          containerCell.appendChild(wrapperDiv);
          containerRow.appendChild(containerCell);

          // Insert the container row immediately after the main row
          if (mainRow.nextSibling) {
            tableBody.insertBefore(containerRow, mainRow.nextSibling);
          } else {
            tableBody.appendChild(containerRow);
          }
        },
        toggleRowExpansion: function (rowId, mainRow) {
          const tableBody = document.querySelector("#sfTable tbody");
          const subRows = tableBody.querySelectorAll(
            "[data-parent-id='" + rowId + "']"
          );
          let isExpanded = this.expandedRows.has(rowId);
          const newDisplay = isExpanded ? "none" : "table-row";
          if (isExpanded) {
            this.expandedRows.delete(rowId);
            mainRow.classList.remove("expanded");
          } else {
            this.expandedRows.add(rowId);
            mainRow.classList.add("expanded");
          }
          subRows.forEach((row) => {
            row.style.display = newDisplay;
          });
        },
        updateTableRowForStep: function (step, updatedResponse) {
          let parsedData = DataManager.parseStatus(updatedResponse);
          console.log(`Updating ${step["Step Name"]} with:`, parsedData);
          if (!parsedData) return;
          let mainRow = document.querySelector(
            "tr[data-step-number='" + step["Step Number"] + "']"
          );
          if (!mainRow) return;
          let mainRowId = mainRow.getAttribute("data-main-row-id");
          if (!mainRowId) return;
          const statusClass = this.getStatusClass(parsedData);
          const nameCell = document.createElement("td");
          const statusSpan = document.createElement("span");
          statusSpan.className = `status-indicator ${statusClass}`;
          nameCell.appendChild(statusSpan);
          const nameStrong = document.createElement("strong");
          nameStrong.textContent = parsedData.name;
          nameCell.appendChild(nameStrong);
          const completedCell = document.createElement("td");
          completedCell.textContent = parsedData.completed;
          const rejectedCell = document.createElement("td");
          rejectedCell.textContent = parsedData.rejected;
          const inProcessCell = document.createElement("td");
          inProcessCell.textContent = parsedData.inProcess;
          const pendingCell = document.createElement("td");
          pendingCell.textContent = parsedData.pending;
          mainRow.innerHTML = "";
          mainRow.appendChild(nameCell);
          mainRow.appendChild(completedCell);
          mainRow.appendChild(rejectedCell);
          mainRow.appendChild(inProcessCell);
          mainRow.appendChild(pendingCell);
          if (mainRow.classList.contains("expandable")) {
            const isExpanded = this.expandedRows.has(mainRowId);
            if (isExpanded) {
              mainRow.classList.add("expanded");
            }
          }
          const tableBody = document.querySelector("#sfTable tbody");
          const existingSubRows = tableBody.querySelectorAll(
            "[data-parent-id='" + mainRowId + "']"
          );
          existingSubRows.forEach((row) => row.remove());
          let oldParsedData = mainRow.oldParsedData || { subProcesses: [] };
          console.log(
            `${step["Step Name"]} subProcesses:`,
            parsedData.subProcesses ? parsedData.subProcesses.length : 0
          );
          let mergedSubProcesses = this.mergeSubProcesses(
            oldParsedData.subProcesses || [],
            parsedData.subProcesses || []
          );
          mainRow.oldParsedData = {
            ...parsedData,
            subProcesses: mergedSubProcesses,
          };
          let groupedSubSteps = mainRow.groupedSubSteps || [];
          if (groupedSubSteps.length > 0) {
            const virtualMain = { subSteps: groupedSubSteps };
            this.addSubRows(
              tableBody,
              virtualMain,
              { ...parsedData, subProcesses: mergedSubProcesses },
              mainRowId
            );
          }
          // Optionally show an update notification bubble with current time
          // this.showUpdateNotification(mainRow);
        },
        mergeSubProcesses: function (oldSubProcesses, newSubProcesses) {
          console.log(
            "Merging subprocesses:",
            "Old:",
            oldSubProcesses.length,
            "New:",
            newSubProcesses.length
          );
          const mapNew = {};
          newSubProcesses.forEach((proc) => {
            mapNew[proc.name] = proc;
          });
          const merged = oldSubProcesses.map((oldProc) =>
            mapNew[oldProc.name] ? mapNew[oldProc.name] : oldProc
          );
          newSubProcesses.forEach((newProc) => {
            if (!merged.some((m) => m.name === newProc.name)) {
              merged.push(newProc);
            }
          });
          console.log("Merged subprocesses count:", merged.length);
          return merged;
        },
        toggleSelectedRow: function (row) {
          const isMainRow = row.classList.contains("main-row");
          const isSubProcess = row.classList.contains("sub-process");
          if (isMainRow) {
            document
              .querySelectorAll(".main-row.selected")
              .forEach((selectedRow) => {
                if (selectedRow !== row) {
                  selectedRow.classList.remove("selected");
                }
              });
          } else if (isSubProcess) {
            document
              .querySelectorAll(".sub-process.selected")
              .forEach((selectedRow) => {
                if (selectedRow !== row) {
                  selectedRow.classList.remove("selected");
                }
              });
          }
          row.classList.toggle("selected");
        },
        /* New function to update all rows without rebuilding the table completely */
        updateAllRows: function () {
          DataManager.steps.forEach((step) => {
            if (step["API Name"]) {
              TableView.updateTableRowForStep(
                step,
                DataManager.responses[step["API Name"]]
              );
            }
          });
        },
        /* New function: shows a bubble notification on the given row with the current time */
        showUpdateNotification: function (row) {
          // Create the notification bubble element
          var bubble = document.createElement("div");
          bubble.className = "update-notification";
          var now = new Date();
          var timeString =
            now.getHours().toString().padStart(2, "0") +
            ":" +
            now.getMinutes().toString().padStart(2, "0") +
            ":" +
            now.getSeconds().toString().padStart(2, "0");
          bubble.textContent = "updated in -" + timeString;
          // Style the bubble (if not already styled via CSS)
          bubble.style.position = "absolute";
          bubble.style.top = "0";
          bubble.style.right = "0";
          bubble.style.backgroundColor = "gray";
          bubble.style.color = "white";
          bubble.style.padding = "5px 10px";
          bubble.style.borderRadius = "5px";
          bubble.style.boxShadow = "0 0 5px rgba(0,0,0,0.3)";
          bubble.style.zIndex = "1000";
          // Ensure the row is relatively positioned
          row.style.position = "relative";
          row.appendChild(bubble);
          // After 3 seconds, fade out the bubble over 2 seconds, then remove it
          setTimeout(function () {
            bubble.style.transition = "opacity 2s";
            bubble.style.opacity = "0";
            setTimeout(function () {
              row.removeChild(bubble);
            }, 2000);
          }, 3000);
        },
      };
    </script>
    <!-- Diagram View Module with minimap functionality -->
    <script>
      const DiagramView = {
        expandedMains: new Set(),
        nodeLookup: {},
        init: function () {
          this.setupTooltip();
          this.setupPan();
          document.getElementById("resetBtn").addEventListener("click", () => {
            this.resetDiagram();
          });
          document.getElementById("centerBtn").addEventListener("click", () => {
            this.centerDiagram();
          });
          document.getElementById("zoomInBtn").addEventListener("click", () => {
            const svg = document.getElementById("diagram");
            const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
            const scale = 0.95;
            const newWidth = viewBox[2] * scale;
            const newHeight = viewBox[3] * scale;
            const newX = viewBox[0] + (viewBox[2] - newWidth) / 2;
            const newY = viewBox[1] + (viewBox[3] - newHeight) / 2;
            svg.setAttribute(
              "viewBox",
              `${newX} ${newY} ${newWidth} ${newHeight}`
            );
            this.updateZoomPercentage();
            this.updateMinimapViewport();
          });
          document
            .getElementById("zoomOutBtn")
            .addEventListener("click", () => {
              const svg = document.getElementById("diagram");
              const viewBox = svg
                .getAttribute("viewBox")
                .split(" ")
                .map(Number);
              const scale = 1.05;
              const newWidth = viewBox[2] * scale;
              const newHeight = viewBox[3] * scale;
              const newX = viewBox[0] - (newWidth - viewBox[2]) / 2;
              const newY = viewBox[1] - (newHeight - viewBox[3]) / 2;
              svg.setAttribute(
                "viewBox",
                `${newX} ${newY} ${newWidth} ${newHeight}`
              );
              this.updateZoomPercentage();
              this.updateMinimapViewport();
            });
          this.expandTopLevelNodes();
          this.buildDiagram();
          this.buildMinimap();
          this.updateZoomPercentage();
          window.addEventListener(
            "resize",
            Utils.debounce(() => {
              this.buildDiagram();
              this.buildMinimap();
            }, 200)
          );
        },
        updateZoomPercentage: function () {
          const svg = document.getElementById("diagram");
          const defaultWidth = 800;
          const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
          const currentWidth = viewBox[2];
          const zoomPercent = (defaultWidth / currentWidth) * 100;
          document.getElementById("zoomPercentage").innerHTML =
            zoomPercent.toFixed(0) + "%";
        },
        setupTooltip: function () {
          this.tooltip = document.getElementById("diagram-tooltip");
          const diagram = document.getElementById("diagram");
          diagram.addEventListener("mousemove", (e) => {
            this.tooltip.style.left = e.pageX + 10 + "px";
            this.tooltip.style.top = e.pageY + 10 + "px";
          });
        },
        setupPan: function () {
          const svg = document.getElementById("diagram");
          let isPanning = false;
          let startX, startY, startViewBox;
          svg.addEventListener("mousedown", function (e) {
            isPanning = true;
            startX = e.clientX;
            startY = e.clientY;
            const viewBoxValues = svg
              .getAttribute("viewBox")
              .split(" ")
              .map(Number);
            startViewBox = {
              x: viewBoxValues[0],
              y: viewBoxValues[1],
              w: viewBoxValues[2],
              h: viewBoxValues[3],
            };
          });
          svg.addEventListener("mousemove", function (e) {
            if (!isPanning) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const scaleX = startViewBox.w / svg.clientWidth;
            const scaleY = startViewBox.h / svg.clientHeight;
            const newX = startViewBox.x - dx * scaleX;
            const newY = startViewBox.y - dy * scaleY;
            svg.setAttribute(
              "viewBox",
              `${newX} ${newY} ${startViewBox.w} ${startViewBox.h}`
            );
            DiagramView.updateMinimapViewport();
          });
          document.addEventListener("mouseup", function () {
            isPanning = false;
          });
        },
        centerDiagram: function () {
          const svg = document.getElementById("diagram");
          svg.setAttribute("viewBox", "0 0 1200 800");
          this.updateMinimapViewport();
          this.updateZoomPercentage();
        },
        resetDiagram: function () {
          const svg = document.getElementById("diagram");
          svg.setAttribute("viewBox", "30 30 800 600");
          this.expandedMains.clear();
          this.expandTopLevelNodes();
          this.buildDiagram();
          this.buildMinimap();
          this.updateZoomPercentage();
        },
        expandTopLevelNodes: function () {
          DataManager.steps.forEach((step) => {
            if (step.Type === "MAIN" && step["Parent Steps"].trim() === "0") {
              this.expandedMains.add(step["Step Number"]);
            }
          });
        },
        update: function () {
          console.log("Updating diagram with latest status data");
          this.cachedData = null;
          this.buildDiagram();
          this.buildMinimap();
          console.log("Diagram update complete");
        },
        getNodeStatus: function (node) {
          let result = {
            status: "unknown",
            completed: "0",
            rejected: "0",
            inProcess: "0",
            pending: "0",
          };
          if (node["API Name"] && DataManager.responses[node["API Name"]]) {
            const parsedData = DataManager.parseStatus(
              DataManager.responses[node["API Name"]]
            );
            if (parsedData) {
              console.log(
                `Direct API status for ${node["Step Name"]}:`,
                parsedData.status
              );
              return parsedData;
            }
          }
          if (node.Type === "SUB" && node["Parent Steps"]) {
            const parentSteps = node["Parent Steps"]
              .split(",")
              .map((p) => p.trim());
            for (let parentId of parentSteps) {
              const parentNode = DataManager.getStepByNumber(parentId);
              if (!parentNode || !parentNode["API Name"]) continue;
              const parentResponse =
                DataManager.responses[parentNode["API Name"]];
              if (!parentResponse) continue;
              const parsedParent = DataManager.parseStatus(parentResponse);
              if (
                !parsedParent ||
                !parsedParent.subProcesses ||
                !parsedParent.subProcesses.length
              )
                continue;
              const subProcess = parsedParent.subProcesses.find(
                (sp) =>
                  sp.name &&
                  sp.name.toLowerCase() === node["Step Name"].toLowerCase()
              );
              if (subProcess) {
                console.log(
                  `Found subprocess ${node["Step Name"]} in parent ${parentNode["Step Name"]} with status: ${subProcess.status}`
                );
                return {
                  status: subProcess.status || "unknown",
                  completed: subProcess.completed || "0",
                  rejected: subProcess.rejected || "0",
                  inProcess: subProcess.inProcess || "0",
                  pending: subProcess.pending || "0",
                };
              }
            }
          }
          return result;
        },
        getVisibleNodes: function () {
          const mainNodes = DataManager.steps.filter((d) => d.Type === "MAIN");
          const subNodes = DataManager.steps.filter((d) => d.Type === "SUB");
          const visibleSubs = [];
          subNodes.forEach((sub) => {
            if (!sub["Parent Steps"]) return;
            const parents = sub["Parent Steps"].split(",").map((p) => p.trim());
            for (let pid of parents) {
              if (this.expandedMains.has(pid)) {
                visibleSubs.push(sub);
                break;
              }
            }
          });
          return [...mainNodes, ...visibleSubs];
        },
        buildDiagram: function () {
          const svg = document.getElementById("diagram");
          while (svg.firstChild) {
            svg.removeChild(svg.firstChild);
          }
          this.nodeLookup = {};
          const visibleNodes = this.getVisibleNodes();
          this.computeLayout(visibleNodes);
          const mapVisible = {};
          visibleNodes.forEach((d) => {
            mapVisible[d["Step Number"]] = d;
          });
          const defs = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "defs"
          );
          const marker = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "marker"
          );
          marker.setAttribute("id", "arrow");
          marker.setAttribute("viewBox", "0 0 10 10");
          marker.setAttribute("refX", "10");
          marker.setAttribute("refY", "5");
          marker.setAttribute("markerWidth", "6");
          marker.setAttribute("markerHeight", "6");
          marker.setAttribute("orient", "auto-start-reverse");
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
          path.setAttribute("fill", "#555");
          marker.appendChild(path);
          defs.appendChild(marker);
          svg.appendChild(defs);
          this.drawEdges(svg, visibleNodes, mapVisible);
          this.drawNodes(svg, visibleNodes);
        },
        computeLayout: function (visibleData) {
          const svg = document.getElementById("diagram");
          const SVG_WIDTH = svg.clientWidth;
          const NODE_WIDTH = 120;
          const NODE_HEIGHT = 40;
          const LEVEL_VERTICAL_SPACING = 100;
          const MARGIN_X = 50;
          const SUB_EXTRA_SPACE = 50;
          const nodesMap = {};
          visibleData.forEach((d) => {
            d.level = d["Parent Steps"].trim() === "0" ? 0 : undefined;
            nodesMap[d["Step Number"]] = d;
          });
          let changed = true;
          while (changed) {
            changed = false;
            visibleData.forEach((item) => {
              if (item["Parent Steps"].trim() !== "0") {
                const parents = item["Parent Steps"]
                  .split(",")
                  .map((s) => s.trim());
                let maxParentLevel = -1;
                parents.forEach((pid) => {
                  const parent = nodesMap[pid];
                  if (
                    parent &&
                    parent.level !== undefined &&
                    parent.level > maxParentLevel
                  ) {
                    maxParentLevel = parent.level;
                  }
                });
                const newLevel = maxParentLevel + 1;
                if (item.level === undefined || newLevel > item.level) {
                  item.level = newLevel;
                  changed = true;
                }
              }
            });
          }
          const levelsMap = {};
          visibleData.forEach((item) => {
            if (!levelsMap[item.level]) {
              levelsMap[item.level] = [];
            }
            levelsMap[item.level].push(item);
          });
          const baseY = 50;
          const offsets = {};
          offsets[0] = 0;
          const levelsSorted = Object.keys(levelsMap)
            .map(Number)
            .sort((a, b) => a - b);
          levelsSorted.forEach((level) => {
            const nodesAtLevel = levelsMap[level];
            const count = nodesAtLevel.length;
            const spacingX = Math.max(
              NODE_WIDTH + 20,
              (SVG_WIDTH - 2 * MARGIN_X) / (count + 1)
            );
            nodesAtLevel.forEach((node, i) => {
              node.x = MARGIN_X + spacingX * (i + 1) - NODE_WIDTH / 2;
              node.y =
                baseY + level * LEVEL_VERTICAL_SPACING + (offsets[level] || 0);
              this.nodeLookup[node["Step Number"]] = {
                x: node.x,
                y: node.y,
                width: NODE_WIDTH,
                height: NODE_HEIGHT,
              };
            });
            let extra = 0;
            nodesAtLevel.forEach((node) => {
              if (
                node.Type === "MAIN" &&
                this.expandedMains.has(node["Step Number"])
              ) {
                const subCount = visibleData.filter((d) => {
                  if (d.Type === "SUB") {
                    if (!d["Parent Steps"]) return false;
                    const parents = d["Parent Steps"]
                      .split(",")
                      .map((s) => s.trim());
                    return parents.includes(node["Step Number"]);
                  }
                  return false;
                }).length;
                if (subCount > 0) {
                  extra = Math.max(extra, subCount * SUB_EXTRA_SPACE);
                }
              }
            });
            offsets[level + 1] = (offsets[level] || 0) + extra;
          });
        },
        drawEdges: function (svg, visibleNodes, mapVisible) {
          const NODE_WIDTH = 120;
          const NODE_HEIGHT = 40;
          visibleNodes.forEach((child) => {
            if (!child["Parent Steps"] || child["Parent Steps"].trim() === "0")
              return;
            const parents = child["Parent Steps"]
              .split(",")
              .map((s) => s.trim());
            parents.forEach((pid) => {
              const parent = mapVisible[pid];
              if (!parent) return;
              const startX = parent.x + NODE_WIDTH / 2;
              const startY = parent.y + NODE_HEIGHT;
              const endX = child.x + NODE_WIDTH / 2;
              const endY = child.y;
              const controlPoint1X = startX;
              const controlPoint1Y = startY + (endY - startY) / 3;
              const controlPoint2X = endX;
              const controlPoint2Y = endY - (endY - startY) / 3;
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
              );
              line.setAttribute(
                "d",
                `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`
              );
              line.setAttribute("class", "edge");
              line.setAttribute("fill", "none");
              svg.appendChild(line);
            });
          });
        },
        drawNodes: function (svg, visibleNodes) {
          const NODE_WIDTH = 120;
          const NODE_HEIGHT = 40;
          visibleNodes.forEach((node) => {
            const g = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            g.setAttribute("class", "node");
            g.setAttribute("id", "node-" + node["Step Number"]);
            const rect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            rect.setAttribute("x", node.x);
            rect.setAttribute("y", node.y);
            rect.setAttribute("width", NODE_WIDTH);
            rect.setAttribute("height", NODE_HEIGHT);
            rect.setAttribute("rx", "10");
            rect.setAttribute("ry", "10");
            let fillColor = "#808080";
            let strokeWidth = "4";
            let strokeColor = "#606060";
            let strokeDashArray = "none";
            const parsedStatus = this.getNodeStatus(node);
            console.log(
              `Drawing node: ${node["Step Name"]}, Status: ${parsedStatus.status}`
            );
            if (parsedStatus) {
              const status = parsedStatus.status
                ? parsedStatus.status.toLowerCase()
                : "";
              if (status === "n/a") {
                fillColor = "#000000";
                strokeColor = "#333333";
              } else if (status === "failed" || status === "rejected") {
                fillColor = "#e74c3c";
                strokeColor = "#c0392b";
              } else if (status === "running" || status === "in process") {
                fillColor = "#2ecc71";
                strokeColor = "#27ae60";
                strokeDashArray = "5, 5";
              } else if (status === "completed") {
                fillColor = "#2ecc71";
                strokeColor = "#27ae60";
              } else if (status === "pending") {
                fillColor = "#ffffff";
                strokeColor = "#999999";
              } else {
                fillColor = "#808080";
                strokeColor = "#606060";
              }
            }
            rect.setAttribute("fill", fillColor);
            rect.setAttribute("stroke", strokeColor);
            rect.setAttribute("stroke-width", strokeWidth);
            if (strokeDashArray !== "none") {
              rect.setAttribute("stroke-dasharray", strokeDashArray);
            }
            g.appendChild(rect);
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            text.setAttribute("x", node.x + NODE_WIDTH / 2);
            text.setAttribute("y", node.y + NODE_HEIGHT / 2 + 5);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("font-size", "12");
            if (fillColor === "#ffffff" || fillColor === "#f2f2f2") {
              text.setAttribute("fill", "#333333");
            } else {
              text.setAttribute("fill", "#ffffff");
            }
            let stepName = node["Step Name"] || "";
            if (stepName.length > 15) {
              stepName = stepName.substring(0, 12) + "...";
            }
            text.textContent = stepName;
            g.appendChild(text);
            if (node.Type === "MAIN") {
              g.addEventListener("click", (e) => {
                e.stopPropagation();
                this.toggleMainExpand(node["Step Number"]);
              });
              g.addEventListener("mouseenter", () => {
                this.showNodeTooltip(node);
              });
              g.addEventListener("mouseleave", () => {
                this.hideNodeTooltip();
              });
            } else {
              g.addEventListener("mouseenter", () => {
                this.showNodeTooltip(node);
              });
              g.addEventListener("mouseleave", () => {
                this.hideNodeTooltip();
              });
            }
            svg.appendChild(g);
          });
        },
        showNodeTooltip: function (node) {
          if (!this.tooltip) return;
          const nodeStatus = this.getNodeStatus(node);
          let tooltipContent = `<strong>${node["Step Name"]}</strong><br>Type: ${node.Type}`;
          if (node["API Name"]) {
            tooltipContent += `<br>API: ${node["API Name"]}`;
          }
          tooltipContent += `<br>Status: <b>${nodeStatus.status}</b>`;
          tooltipContent += `<br>Completed: ${nodeStatus.completed}`;
          tooltipContent += `<br>Rejected: ${nodeStatus.rejected}`;
          tooltipContent += `<br>In Process: ${nodeStatus.inProcess}`;
          tooltipContent += `<br>Pending: ${nodeStatus.pending}`;
          this.tooltip.innerHTML = tooltipContent;
          this.tooltip.style.opacity = "1";
        },
        hideNodeTooltip: function () {
          if (!this.tooltip) return;
          this.tooltip.style.opacity = "0";
        },
        toggleMainExpand: function (mainId) {
          if (this.expandedMains.has(mainId)) {
            this.expandedMains.delete(mainId);
          } else {
            this.expandedMains.add(mainId);
          }
          this.buildDiagram();
          this.buildMinimap();
        },
        buildMinimap: function () {
          const scaleFactor = 0.2;
          const mainSvg = document.getElementById("diagram");
          const minimapSvg = document.getElementById("minimap");
          while (minimapSvg.firstChild) {
            minimapSvg.removeChild(minimapSvg.firstChild);
          }
          const viewportRect = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "rect"
          );
          viewportRect.setAttribute("id", "minimap-viewport");
          viewportRect.setAttribute("fill", "none");
          viewportRect.setAttribute("stroke", "red");
          viewportRect.setAttribute("stroke-width", "2");
          minimapSvg.appendChild(viewportRect);
          const visibleNodes = this.getVisibleNodes();
          visibleNodes.forEach((node) => {
            const scaledX = node.x * scaleFactor;
            const scaledY = node.y * scaleFactor;
            const scaledWidth = 120 * scaleFactor;
            const scaledHeight = 40 * scaleFactor;
            const rect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            rect.setAttribute("x", scaledX);
            rect.setAttribute("y", scaledY);
            rect.setAttribute("width", scaledWidth);
            rect.setAttribute("height", scaledHeight);
            rect.setAttribute("fill", "#1483f3");
            rect.setAttribute("stroke", "#606060");
            rect.setAttribute("stroke-width", "1");
            minimapSvg.appendChild(rect);
          });
          this.updateMinimapViewport();
        },
        updateMinimapViewport: function () {
          const scaleFactor = 0.2;
          const mainSvg = document.getElementById("diagram");
          const viewBox = mainSvg
            .getAttribute("viewBox")
            .split(" ")
            .map(Number);
          const minimapViewport = document.getElementById("minimap-viewport");
          minimapViewport.setAttribute("x", viewBox[0] * scaleFactor);
          minimapViewport.setAttribute("y", viewBox[1] * scaleFactor);
          minimapViewport.setAttribute("width", viewBox[2] * scaleFactor);
          minimapViewport.setAttribute("height", viewBox[3] * scaleFactor);
        },
      };
    </script>
  </body>
</html>
