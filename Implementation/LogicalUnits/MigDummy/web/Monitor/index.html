<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Table + Diagram - Side by Side (Responsive)</title>
    <style>
      /* Global styling */
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background-color: #f4f4f9;
      }
      .container {
        display: flex;
        flex-direction: row;
        height: 100vh;
      }
      .table-container,
      .diagram-container {
        flex: 1;
        padding: 20px;
        box-sizing: border-box;
        position: relative;
      }
      .table-container {
        overflow-y: auto;
      }
      .diagram-container {
        overflow: hidden; /* No scrolling in the diagram container */
      }
      /* Table styling */
      #loading,
      #error-message {
        font-size: 18px;
        margin-bottom: 20px;
      }
      #loading {
        color: #333;
      }
      #error-message {
        color: #e74c3c;
        display: none;
      }
      h3 {
        color: #1483f3;
        font-size: 22px;
        margin-bottom: 15px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        background-color: #fff;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        table-layout: fixed;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
        white-space: nowrap;
        font-size: 13px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      /* Column widths */
      th:first-child,
      td:first-child {
        width: 35%;
        position: relative; /* Added for absolute positioning of expand icon */
      }
      th:not(:first-child),
      td:not(:first-child) {
        width: 16.25%;
        text-align: right; /* Right-align numeric data */
        padding-right: 20px; /* Add consistent padding */
      }
      th {
        background-color: #1483f3;
        color: white;
        font-weight: bold;
      }
      tr:nth-child(even) {
        background-color: #f2f2f2;
      }
      tr:hover {
        background-color: #ddd;
      }
      .sub-header {
        background-color: #3382d1;
        color: #fff;
        font-weight: bold;
      }
      .separator-row {
        background-color: #f2f2f2;
      }
      .spacer-row td {
        border: none;
      }
      .main-row {
        cursor: pointer;
      }
      /* Expandable row styling */
      .main-row.expandable td:first-child {
        position: relative;
        padding-left: 20px;
      }
      .main-row.expandable td:first-child::before {
        content: "â–¶";
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        transition: transform 0.2s;
        cursor: pointer;
      }
      .main-row.expandable.expanded td:first-child::before {
        transform: translateY(-50%) rotate(90deg);
      }
      .sub-process td:first-child {
        padding-left: 25px;
      }
      /* Improved hierarchy indicators */
      .hierarchy-indicator {
        display: inline-block;
        width: 16px;
        height: 16px;
        text-align: center;
        line-height: 16px;
        margin-right: 8px;
      }
      /* Indent levels */
      .indent-level-1 {
        padding-left: 25px !important;
      }
      .indent-level-2 {
        padding-left: 45px !important;
      }
      /* Diagram styling */
      #diagram {
        width: 100%;
        height: 100%;
        display: block;
      }
      .node rect {
        fill: #1483f3;
        stroke-width: 4;
        cursor: pointer;
      }
      .node text {
        fill: #ffffff;
        font-size: 12px;
        pointer-events: none;
      }
      .edge {
        stroke: #555;
        stroke-width: 2;
        marker-end: url(#arrow);
      }
      /* Status indicator styling */
      .status-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 5px;
      }
      .status-completed {
        background-color: #2ecc71;
      } /* Green */
      .status-in-progress {
        background-color: #2ecc71;
        border: 1px dashed #27ae60;
      } /* Green with dash */
      .status-pending {
        background-color: #ffffff;
        border: 1px solid #cccccc;
      } /* White */
      .status-rejected {
        background-color: #e74c3c;
      } /* Red */
      .status-na {
        background-color: #000000;
      } /* Black */
      .status-default {
        background-color: #808080;
      } /* Gray */
      /* Tooltip styling */
      .tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 1000;
      }
      /* Responsive adjustments */
      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
        .table-container,
        .diagram-container {
          height: 50vh;
          width: 100%;
        }
      }
      /* Loading spinner */
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border-left-color: #1483f3;
        display: inline-block;
        margin-right: 10px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Table Section -->
      <div class="table-container">
        <div id="loading">
          <span class="spinner"></span> Loading data, please wait...
        </div>
        <div id="error-message">
          Error loading data. Please try again or contact support.
        </div>
        <h3 id="Exec_ID">Run Number: 0</h3>
        <table id="sfTable" style="display: none">
          <thead>
            <tr>
              <th>Name</th>
              <th>Completed</th>
              <th>Rejected</th>
              <th>In Process</th>
              <th>Pending</th>
            </tr>
          </thead>
          <tbody>
            <!-- Dynamic rows will be inserted here -->
          </tbody>
        </table>
      </div>
      <!-- Diagram Section -->
      <div class="diagram-container">
        <svg id="diagram"></svg>
        <div class="tooltip" id="diagram-tooltip"></div>
      </div>
    </div>

    <!-- Shared k2api configuration and navigation menu setup -->
    <script>
      window.onload = function () {
        window.k2api = window.k2api || window.parent.k2api;
        if (!window.k2api) {
          // Mock k2api for demonstration if no external environment exists
          window.k2api = {
            setNavigationMenu: function () {},
            invokeFabricWebService: async function (apiName, params, method) {
              console.log("Mock call:", apiName, params, method);
              return Promise.resolve({});
            },
          };
        }
        window.k2api.setNavigationMenu([
          { name: "Main", path: "/index.html" },
          { name: "Table", path: "/table5.html" },
          { name: "Diagram", path: "/table6.html" },
        ]);

        // Initialize application
        DataManager.init();
      };
    </script>

    <!-- Utility Functions -->
    <script>
      // Utility functions
      const Utils = {
        /**
         * Safe JSON parse with fallback
         * @param {string} str - JSON string to parse
         * @param {*} fallback - Fallback value if parsing fails
         * @returns {*} Parsed object or fallback
         */
        safeJsonParse: function (str, fallback) {
          try {
            return JSON.parse(str);
          } catch (e) {
            console.error("Error parsing JSON:", e);
            return fallback;
          }
        },

        /**
         * Show error message to user
         * @param {string} message - Error message
         * @param {Error} [error] - Error object (optional)
         */
        showError: function (message, error) {
          const errorElement = document.getElementById("error-message");
          if (errorElement) {
            errorElement.textContent = message;
            errorElement.style.display = "block";
            document.getElementById("loading").style.display = "none";
          }
          console.error(message, error);
        },

        /**
         * Hide error message
         */
        hideError: function () {
          const errorElement = document.getElementById("error-message");
          if (errorElement) {
            errorElement.style.display = "none";
          }
        },

        /**
         * Debounce function to limit execution frequency
         * @param {Function} func - Function to debounce
         * @param {number} wait - Wait time in milliseconds
         * @returns {Function} Debounced function
         */
        debounce: function (func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        },
      };
    </script>

    <!-- Data Manager Module -->
    <script>
      // Data Manager Module
      const DataManager = {
        steps: [],
        responses: {},
        execId: 0,

        /**
         * Initialize data loading
         */
        init: async function () {
          try {
            Utils.hideError();
            await this.loadData();
            TableView.init();
            DiagramView.init();
            this.setupRefreshIntervals();
          } catch (error) {
            Utils.showError("Failed to initialize the application", error);
          }
        },

        /**
         * Load steps configuration and API responses
         */
        loadData: async function () {
          try {
            Utils.hideError();

            // Getting execution ID with flexible extraction
            let execId;
            try {
              const wsExecIdResponse = await k2api.invokeFabricWebService(
                "wsExecId",
                { token: "", format: "json" },
                "GET"
              );

              // More flexible execId extraction
              execId =
                wsExecIdResponse?.execId ||
                (typeof wsExecIdResponse === "object"
                  ? Object.values(wsExecIdResponse)[0]
                  : wsExecIdResponse);

              if (!execId) {
                throw new Error("Could not extract execution ID");
              }
            } catch (execError) {
              console.error("Execution ID fetch failed:", execError);
              execId = Date.now(); // Fallback solution
            }

            this.execId = execId;
            document.getElementById("Exec_ID").innerHTML =
              "Run Number: " + this.execId;

            // More flexible step configuration extraction
            let steps;
            try {
              steps = await k2api.invokeFabricWebService(
                "wsMonitorConfig",
                { token: "", format: "json" },
                "GET"
              );

              // Convert to steps array if needed
              steps = Array.isArray(steps)
                ? steps
                : typeof steps === "object"
                ? Object.values(steps)
                : [];
            } catch (configError) {
              console.error("Steps configuration fetch failed:", configError);
              steps = []; // Fallback solution
            }

            if (steps.length === 0) {
              throw new Error("No steps found in configuration");
            }

            this.steps = steps;

            // Load API responses with error handling
            this.responses = await this.fetchAllApiResponses(this.steps);
            console.log("Loaded API responses:", this.responses);

            document.getElementById("loading").style.display = "none";
            document.getElementById("sfTable").style.display = "table";

            // Immediate call to build table
            TableView.init();
          } catch (error) {
            Utils.showError("Failed to load initial data", error);

            // Show table even with error
            document.getElementById("loading").style.display = "none";
            document.getElementById("sfTable").style.display = "table";
          }
        },

        /**
         * Fetch responses for all APIs
         * @param {Array} steps - Step configuration array
         * @returns {Object} Map of API responses
         */
        fetchAllApiResponses: async function (steps) {
          const responses = {};
          const tasks = [];
          steps.forEach((step) => {
            if (step["API Name"]) {
              tasks.push(
                this.fetchApiResponse(step["API Name"])
                  .then((response) => {
                    responses[step["API Name"]] = response;
                  })
                  .catch((error) => {
                    console.error(
                      `Error fetching data for ${step["API Name"]}:`,
                      error
                    );
                  })
              );
            }
          });
          await Promise.allSettled(tasks);
          return responses;
        },

        /**
         * Fetch single API response
         * @param {string} apiName - API name to fetch
         * @returns {Promise<Object>} API response
         */
        fetchApiResponse: async function (apiName) {
          try {
            const response = await k2api.invokeFabricWebService(
              apiName,
              { token: "", execId: this.execId },
              "GET"
            );

            // Log response for debugging
            console.log(`Response from ${apiName}:`, response);

            // If response is an object or array, check its structure recursively
            if (typeof response === "object" && response !== null) {
              console.log(`Response structure for ${apiName}:`);
              this.logObjectStructure(response);
            }

            return response;
          } catch (error) {
            console.error(`Error fetching API ${apiName}:`, error);
            throw error;
          }
        },

        /**
         * Function to check object structure recursively to a limited depth
         * @param {Object} obj - Object to log structure of
         * @param {number} depth - Current depth level
         * @param {number} maxDepth - Maximum depth to log
         */
        logObjectStructure: function (obj, depth = 0, maxDepth = 2) {
          if (depth > maxDepth) {
            console.log("  ".repeat(depth) + "[Max depth reached]");
            return;
          }

          if (Array.isArray(obj)) {
            console.log(
              "  ".repeat(depth) + "Array with " + obj.length + " items"
            );
            if (obj.length > 0) {
              console.log("  ".repeat(depth) + "First item:");
              this.logObjectStructure(obj[0], depth + 1, maxDepth);
            }
          } else if (typeof obj === "object" && obj !== null) {
            const keys = Object.keys(obj);
            console.log(
              "  ".repeat(depth) + "Object with " + keys.length + " keys"
            );
            for (const key of keys) {
              const value = obj[key];
              const valueType = typeof value;
              if (valueType === "object" && value !== null) {
                console.log(
                  "  ".repeat(depth) +
                    key +
                    ": [" +
                    (Array.isArray(value) ? "Array" : "Object") +
                    "]"
                );
                this.logObjectStructure(value, depth + 1, maxDepth);
              } else {
                const strValue =
                  valueType === "string"
                    ? value.length > 50
                      ? value.substring(0, 47) + "..."
                      : value
                    : String(value);
                console.log(
                  "  ".repeat(depth) +
                    key +
                    ": " +
                    valueType +
                    " (" +
                    strValue +
                    ")"
                );
              }
            }
          } else {
            console.log("  ".repeat(depth) + "Value: " + String(obj));
          }
        },

        /**
         * Full data refresh mechanism
         * Refreshes all API responses and updates both table and diagram views
         */
        refreshAllData: async function () {
          console.log("Performing full data refresh...");

          try {
            // Fetch all API responses again
            const updatedResponses = await this.fetchAllApiResponses(
              this.steps
            );

            // Update the responses object
            this.responses = updatedResponses;

            // Update table view
            TableView.init();

            // Update diagram view
            DiagramView.update();

            console.log("Full data refresh complete");
          } catch (error) {
            console.error("Error during full data refresh:", error);
          }
        },

        /**
         * Setup refresh intervals for APIs
         */
        setupRefreshIntervals: function () {
          // Add a master refresh interval (every 30 seconds)
          const MASTER_REFRESH_INTERVAL = 30000; // 30 seconds
          setInterval(() => {
            this.refreshAllData();
          }, MASTER_REFRESH_INTERVAL);

          // Individual API refresh intervals
          this.steps.forEach((step) => {
            if (step["API Name"] && step["Refresh interval"]) {
              const interval = parseInt(step["Refresh interval"], 10) * 1000;
              if (isNaN(interval) || interval <= 0) return;

              setInterval(async () => {
                try {
                  console.log(`Refreshing API: ${step["API Name"]}`);
                  const updatedResponse = await this.fetchApiResponse(
                    step["API Name"]
                  );

                  // Store the response
                  this.responses[step["API Name"]] = updatedResponse;

                  // Update table immediately
                  TableView.updateTableRowForStep(step, updatedResponse);

                  // Force diagram update
                  DiagramView.update();

                  console.log(`API refresh complete: ${step["API Name"]}`);
                } catch (error) {
                  console.error(
                    `Error in refresh interval for ${step["API Name"]}:`,
                    error
                  );
                }
              }, interval);
            }
          });
        },

        /**
         * Group steps into main steps and substeps
         * @returns {Array} Grouped steps
         */
        getGroupedSteps: function () {
          const mainSteps = this.steps.filter((step) => step.Type === "MAIN");
          const subSteps = this.steps.filter((step) => step.Type === "SUB");

          mainSteps.forEach((main) => {
            const mainNum = main["Step Number"];
            main.subSteps = subSteps.filter((sub) => {
              if (!sub["Parent Steps"]) return false;
              const parents = sub["Parent Steps"]
                .split(",")
                .map((s) => s.trim());
              return parents.includes(mainNum);
            });
          });

          return mainSteps;
        },

        /**
         * Parse status information from API response - IMPROVED IMPLEMENTATION
         * This function handles both the main process and subprocesses correctly
         *
         * @param {string|Object} response - API response to parse
         * @returns {Object|null} Parsed status object or null
         */
        parseStatus: function (response) {
          try {
            // Step 1: Handle null/undefined response
            if (!response) return null;

            // Step 2: Handle array responses - extract first item
            // The API often returns arrays like [{"sfLoadStatus": "..."}]
            let data = response;
            if (Array.isArray(data)) {
              data = data.length > 0 ? data[0] : null;
              // Handle nested arrays if they exist
              if (Array.isArray(data)) {
                data = data.length > 0 ? data[0] : null;
              }
            }
            if (!data) return null;

            // Step 3: Get the status string - might be in any property of the object
            // For example: {"sfLoadStatus": "name=SF Load, status=running, completed=97..."}
            let statusString = null;
            if (typeof data === "object") {
              // Find the first property that contains status information
              for (const key in data) {
                if (
                  data[key] &&
                  typeof data[key] === "string" &&
                  (data[key].includes("status=") ||
                    data[key].includes('"status":'))
                ) {
                  statusString = data[key];
                  console.log(
                    `Found status string in property '${key}'`,
                    statusString.substring(0, 50) + "..."
                  );
                  break;
                }
              }
            } else if (typeof data === "string") {
              statusString = data;
            }

            if (!statusString) {
              console.warn("No status string found in response");
              return null;
            }

            // Step 4: Extract status using regex
            let status = "unknown";
            const statusMatch = statusString.match(/status=([^,}]+)/);
            if (statusMatch) {
              status = statusMatch[1].trim();
              console.log("Extracted status:", status);
            }

            // Step 5: Build the result object with all needed fields
            const result = {
              status: status,
              name: "",
              completed: "0",
              rejected: "0",
              inProcess: "0",
              pending: "0",
              subProcesses: [],
            };

            // Step 6: Extract name and counts
            const nameMatch = statusString.match(/name=([^,}]+)/);
            if (nameMatch) {
              result.name = nameMatch[1].trim();
            }

            // Extract numerical values
            const completedMatch = statusString.match(/completed=([^,}]+)/);
            if (completedMatch) {
              result.completed = completedMatch[1].trim();
            }

            const rejectedMatch = statusString.match(/rejected=([^,}]+)/);
            if (rejectedMatch) {
              result.rejected = rejectedMatch[1].trim();
            }

            const inProcessMatch = statusString.match(/in process=([^,}]+)/);
            if (inProcessMatch) {
              result.inProcess = inProcessMatch[1].trim();
            }

            const pendingMatch = statusString.match(/pending=([^,}]+)/);
            if (pendingMatch) {
              result.pending = pendingMatch[1].trim();
            }

            // Step 7: IMPORTANT - Extract subProcesses properly
            // This is a critical part that was previously not working correctly
            console.log("Extracting subProcesses from status string...");
            const subProcessPart = statusString.match(/subProcesses=\[(.*)\]/s);
            if (subProcessPart && subProcessPart[1]) {
              console.log(
                "Found subProcesses section:",
                subProcessPart[1].substring(0, 50) + "..."
              );

              // Method 1: Extract using precise regex pattern for each subprocess
              // This matches the exact format seen in the API responses
              const subProcessRegex =
                /\{name=([^,]+), status=([^,]+), completed=([^,]+), rejected=([^,]+), in process=([^,]+), pending=([^,}]+)\}/g;

              let match;
              while (
                (match = subProcessRegex.exec(subProcessPart[1])) !== null
              ) {
                console.log("Found subprocess via regex:", match[1]);
                result.subProcesses.push({
                  name: match[1].trim(),
                  status: match[2].trim(),
                  completed: match[3].trim(),
                  rejected: match[4].trim(),
                  inProcess: match[5].trim(),
                  pending: match[6].trim(),
                });
              }

              // Method 2: Fallback - if regex fails, try manual string splitting
              // This provides a robust backup if the format changes slightly
              if (result.subProcesses.length === 0) {
                console.log(
                  "Primary regex failed, attempting manual parsing of subprocesses"
                );
                const items = subProcessPart[1].split("}, {");
                console.log(
                  `Found ${items.length} subprocesses by manual splitting`
                );

                for (let item of items) {
                  // Ensure the item has proper enclosing braces
                  if (!item.startsWith("{")) {
                    item = "{" + item;
                  }
                  if (!item.endsWith("}")) {
                    item = item + "}";
                  }

                  console.log("Processing subprocess item:", item);

                  // Extract each field individually
                  const nameMatch = item.match(/name=([^,]+)/);
                  const statusMatch = item.match(/status=([^,]+)/);
                  const completedMatch = item.match(/completed=([^,]+)/);
                  const rejectedMatch = item.match(/rejected=([^,]+)/);
                  const inProcessMatch = item.match(/in process=([^,]+)/);
                  const pendingMatch = item.match(/pending=([^,}]+)/);

                  if (nameMatch) {
                    console.log(
                      "Found subprocess via manual parsing:",
                      nameMatch[1]
                    );
                    result.subProcesses.push({
                      name: nameMatch[1].trim(),
                      status: statusMatch ? statusMatch[1].trim() : "unknown",
                      completed: completedMatch
                        ? completedMatch[1].trim()
                        : "0",
                      rejected: rejectedMatch ? rejectedMatch[1].trim() : "0",
                      inProcess: inProcessMatch
                        ? inProcessMatch[1].trim()
                        : "0",
                      pending: pendingMatch ? pendingMatch[1].trim() : "0",
                    });
                  }
                }
              }
            }

            // Log the final result for debugging
            console.log("Final parsed result with subProcesses:", result);
            console.log(
              `Found ${result.subProcesses.length} subprocesses in total`
            );

            return result;
          } catch (error) {
            console.error("Error parsing status:", error);
            return null;
          }
        },

        /**
         * Get step from steps array by number
         * @param {string} stepNumber - Step number
         * @returns {Object|null} Step object or null
         */
        getStepByNumber: function (stepNumber) {
          return (
            this.steps.find((step) => step["Step Number"] === stepNumber) ||
            null
          );
        },
      };
    </script>

    <!-- Table View Module -->
    <script>
      // Table View Module
      const TableView = {
        expandedRows: new Set(),

        /**
         * Initialize table view
         */
        init: function () {
          this.buildTable(DataManager.getGroupedSteps(), DataManager.responses);
          window.addEventListener(
            "resize",
            Utils.debounce(() => {
              this.adjustTableWidth();
            }, 200)
          );
          this.adjustTableWidth();
        },

        /**
         * Adjust table width based on content
         */
        adjustTableWidth: function () {
          const table = document.getElementById("sfTable");
          if (!table) return;

          const containerWidth = table.parentElement.clientWidth;
          table.style.width = Math.min(containerWidth, 1200) + "px";
        },

        /**
         * Build table with grouped steps
         * @param {Array} groupedSteps - Grouped steps
         * @param {Object} responses - API responses
         */
        buildTable: function (groupedSteps, responses) {
          const tableBody = document.querySelector("#sfTable tbody");
          tableBody.innerHTML = "";

          for (
            let mainRowCounter = 0;
            mainRowCounter < groupedSteps.length;
            mainRowCounter++
          ) {
            const main = groupedSteps[mainRowCounter];

            // Get status for main step
            let parsedMain = null;

            if (main["API Name"] && responses[main["API Name"]]) {
              let resp = responses[main["API Name"]];
              // Parse the response using the enhanced parsing function
              parsedMain = DataManager.parseStatus(resp);
              console.log(`Parsed data for ${main["Step Name"]}:`, parsedMain);
            }

            // Fallback to defaults if we still don't have parsed data
            if (!parsedMain) {
              parsedMain = {
                name: main["Step Name"] || "Unknown Step",
                status: "unknown",
                completed: "0",
                rejected: "0",
                inProcess: "0",
                pending: "0",
                subProcesses: [],
              };
            }

            // Create main row
            const mainRow = document.createElement("tr");
            mainRow.setAttribute("data-step-number", main["Step Number"]);
            mainRow.classList.add("main-row");

            // Add expandable class if there are substeps
            if (main.subSteps && main.subSteps.length > 0) {
              mainRow.classList.add("expandable");
              if (this.expandedRows.has(mainRowCounter.toString())) {
                mainRow.classList.add("expanded");
              }
            }

            mainRow.setAttribute("data-main-row-id", mainRowCounter);
            if (main["API Name"]) {
              mainRow.setAttribute("data-api-name", main["API Name"]);
            }

            // Store the grouped substeps and parsed data for later use
            mainRow.groupedSubSteps = main.subSteps || [];
            mainRow.oldParsedData = parsedMain;

            // Get status color based on status
            const statusClass = this.getStatusClass(parsedMain);

            // Create name cell with status indicator
            const nameCell = document.createElement("td");

            // Add status indicator
            const statusSpan = document.createElement("span");
            statusSpan.className = `status-indicator ${statusClass}`;
            nameCell.appendChild(statusSpan);

            // Add name with appropriate styling
            const nameStrong = document.createElement("strong");
            nameStrong.textContent = parsedMain.name;
            nameCell.appendChild(nameStrong);

            // Add cell to row
            mainRow.appendChild(nameCell);

            // Add data cells
            const completedCell = document.createElement("td");
            completedCell.textContent = parsedMain.completed;
            mainRow.appendChild(completedCell);

            const rejectedCell = document.createElement("td");
            rejectedCell.textContent = parsedMain.rejected;
            mainRow.appendChild(rejectedCell);

            const inProcessCell = document.createElement("td");
            inProcessCell.textContent = parsedMain.inProcess;
            mainRow.appendChild(inProcessCell);

            const pendingCell = document.createElement("td");
            pendingCell.textContent = parsedMain.pending;
            mainRow.appendChild(pendingCell);

            // Add click event for expandable rows
            if (main.subSteps && main.subSteps.length > 0) {
              mainRow.addEventListener("click", () => {
                const id = mainRow.getAttribute("data-main-row-id");
                this.toggleRowExpansion(id, mainRow);
              });
            } else {
              mainRow.style.cursor = "default";
            }

            tableBody.appendChild(mainRow);

            // Add sub-rows if any
            if (main.subSteps && main.subSteps.length > 0) {
              this.addSubRows(tableBody, main, parsedMain, mainRowCounter);
            }
          }
        },

        /**
         * Get CSS class based on status value - IMPROVED
         * Maps the direct status field to the appropriate CSS class
         *
         * @param {Object} data - Status data with status field
         * @returns {string} CSS class for status
         */
        getStatusClass: function (data) {
          if (!data || !data.status) return "status-default";

          const status = data.status.toLowerCase();

          // Map status strings to classes based on requirements
          // This is a direct mapping from status field to CSS class
          if (status === "n/a") return "status-na";
          if (status === "failed" || status === "rejected")
            return "status-rejected";
          if (status === "running" || status === "in process")
            return "status-in-progress";
          if (status === "completed") return "status-completed";
          if (status === "pending") return "status-pending";

          return "status-default"; // Default grey for unknown status
        },

        /**
         * Add sub-rows to table for a main step
         * This function creates the hierarchical view of subprocesses in the table
         *
         * @param {HTMLElement} tableBody - Table body element
         * @param {Object} main - Main step configuration
         * @param {Object} parsedMain - Parsed main step data with subProcesses
         * @param {number} mainRowCounter - Main row counter/ID
         */
        addSubRows: function (tableBody, main, parsedMain, mainRowCounter) {
          console.log(
            `Adding sub-rows for ${main["Step Name"]} with ${
              parsedMain.subProcesses ? parsedMain.subProcesses.length : 0
            } subProcesses`
          );

          // Check if row is expanded or collapsed
          const isExpanded = this.expandedRows.has(mainRowCounter.toString());
          const displayStyle = isExpanded ? "table-row" : "none";

          // Get reference to the main row
          const mainRow = tableBody.querySelector(
            `tr[data-main-row-id="${mainRowCounter}"]`
          );
          if (!mainRow) return;

          // Create sub-rows container
          const subRowsContainer = document.createElement("tbody");

          // Add sub-header row
          const subHeaderRow = document.createElement("tr");
          subHeaderRow.classList.add("sub-header");
          subHeaderRow.setAttribute("data-parent-id", mainRowCounter);
          subHeaderRow.style.display = displayStyle;
          subHeaderRow.innerHTML = `
            <th>Name</th>
            <th>Completed</th>
            <th>Rejected</th>
            <th>In Process</th>
            <th>Pending</th>
          `;
          subRowsContainer.appendChild(subHeaderRow);

          // Add sub-process rows (one for each substep)
          main.subSteps.forEach((sub) => {
            // Find sub-process data either from direct API or from parent's subProcesses
            let parsedSub = null;

            // Method 1: Try to get data from direct API call to the subprocess
            if (sub["API Name"] && DataManager.responses[sub["API Name"]]) {
              let resp = DataManager.responses[sub["API Name"]];
              parsedSub = DataManager.parseStatus(resp);
              console.log(
                `Found direct data for subprocess ${sub["Step Name"]}:`,
                parsedSub
              );
            }

            // Method 2: If not found from API, look for it in the main process subProcesses array
            if (
              !parsedSub &&
              parsedMain.subProcesses &&
              parsedMain.subProcesses.length > 0
            ) {
              // Find matching subprocess by name
              parsedSub = parsedMain.subProcesses.find(
                (item) =>
                  item.name.toLowerCase() === sub["Step Name"].toLowerCase()
              );

              if (parsedSub) {
                console.log(
                  `Found subprocess ${sub["Step Name"]} in parent's subProcesses array:`,
                  parsedSub
                );
              }
            }

            // Method 3: If still not found, create default values
            if (!parsedSub) {
              console.log(
                `No data found for subprocess ${sub["Step Name"]}, using defaults`
              );
              parsedSub = {
                name: sub["Step Name"],
                status: "unknown",
                completed: "0",
                rejected: "0",
                inProcess: "0",
                pending: "0",
              };
            }

            // Get status class
            const statusClass = this.getStatusClass(parsedSub);

            // Create header-less sub-row
            const subRow = document.createElement("tr");
            subRow.classList.add("sub-process");
            subRow.setAttribute("data-parent-id", mainRowCounter);
            if (sub["API Name"]) {
              subRow.setAttribute("data-api-name", sub["API Name"]);
            }
            subRow.style.display = displayStyle;

            // Create nameCell with vertical line in a separate container
            const nameCell = document.createElement("td");

            // Create an inner container div to hold all content
            const nameContainer = document.createElement("div");
            nameContainer.className = "cell-container";

            // Add vertical line for SF and DS Load to show they're similar level
            if (
              parsedSub.name.includes("SF") ||
              parsedSub.name.includes("DS")
            ) {
              const verticalLine = document.createElement("span");
              verticalLine.style.display = "inline-block";
              verticalLine.style.width = "3px";
              verticalLine.style.height = "14px";
              verticalLine.style.backgroundColor = "#1483f3";
              verticalLine.style.marginRight = "6px";
              verticalLine.style.flexShrink = "0";
              nameContainer.appendChild(verticalLine);
            }

            // Add status indicator
            const statusSpan = document.createElement("span");
            statusSpan.className = `status-indicator ${statusClass}`;
            statusSpan.style.flexShrink = "0";
            statusSpan.style.marginRight = "6px";
            nameContainer.appendChild(statusSpan);

            // Add name with proper spacing in a span to control overflow
            const nameSpan = document.createElement("span");
            nameSpan.className = "name-container";
            nameSpan.textContent = parsedSub.name;
            nameContainer.appendChild(nameSpan);

            // Add the container to the cell
            nameCell.appendChild(nameContainer);

            // Create the data cells for numeric values
            const completedCell = document.createElement("td");
            completedCell.textContent = parsedSub.completed;

            const rejectedCell = document.createElement("td");
            rejectedCell.textContent = parsedSub.rejected;

            const inProcessCell = document.createElement("td");
            inProcessCell.textContent = parsedSub.inProcess;

            const pendingCell = document.createElement("td");
            pendingCell.textContent = parsedSub.pending;

            // Append all cells to the row
            subRow.appendChild(nameCell);
            subRow.appendChild(completedCell);
            subRow.appendChild(rejectedCell);
            subRow.appendChild(inProcessCell);
            subRow.appendChild(pendingCell);

            subRowsContainer.appendChild(subRow);
          });

          // Add separator and spacer rows
          const separatorRow = document.createElement("tr");
          separatorRow.classList.add("separator-row");
          separatorRow.setAttribute("data-parent-id", mainRowCounter);
          separatorRow.style.display = displayStyle;
          separatorRow.innerHTML = `<td colspan="5"></td>`;
          subRowsContainer.appendChild(separatorRow);

          const spacerRow = document.createElement("tr");
          spacerRow.classList.add("spacer-row");
          spacerRow.setAttribute("data-parent-id", mainRowCounter);
          spacerRow.style.display = displayStyle;
          spacerRow.innerHTML = `<td colspan="5"></td>`;
          subRowsContainer.appendChild(spacerRow);

          // Insert sub-rows right after the main row
          if (mainRow.nextSibling) {
            tableBody.insertBefore(subRowsContainer, mainRow.nextSibling);
          } else {
            tableBody.appendChild(subRowsContainer);
          }

          // Move all child nodes from subRowsContainer to tableBody
          while (subRowsContainer.firstChild) {
            tableBody.insertBefore(
              subRowsContainer.firstChild,
              subRowsContainer
            );
          }

          // Remove the temporary container
          if (subRowsContainer.parentNode) {
            subRowsContainer.parentNode.removeChild(subRowsContainer);
          }
        },

        /**
         * Toggle row expansion (show/hide sub-rows)
         * @param {string} rowId - Row ID
         * @param {HTMLElement} mainRow - Main row element
         */
        toggleRowExpansion: function (rowId, mainRow) {
          const tableBody = document.querySelector("#sfTable tbody");

          // Find all sub-rows associated with this main row
          const subRows = tableBody.querySelectorAll(
            "[data-parent-id='" + rowId + "']"
          );

          // Check if currently expanded
          let isExpanded = this.expandedRows.has(rowId);
          const newDisplay = isExpanded ? "none" : "table-row";

          // Toggle expansion state
          if (isExpanded) {
            this.expandedRows.delete(rowId);
            mainRow.classList.remove("expanded");
          } else {
            this.expandedRows.add(rowId);
            mainRow.classList.add("expanded");
          }

          // Show/hide all sub-rows
          subRows.forEach((row) => {
            row.style.display = newDisplay;
          });
        },

        /**
         * Update table row for a specific step when API data changes
         * This is a critical function that handles updates to both main rows and sub-rows
         *
         * @param {Object} step - Step configuration
         * @param {Object} updatedResponse - Updated API response
         */
        updateTableRowForStep: function (step, updatedResponse) {
          // Parse data from updated response using the enhanced parsing function
          let parsedData = DataManager.parseStatus(updatedResponse);
          console.log(`Updating ${step["Step Name"]} with:`, parsedData);

          if (!parsedData) return;

          // Find main row in the table
          let mainRow = document.querySelector(
            "tr[data-step-number='" + step["Step Number"] + "']"
          );
          if (!mainRow) return;

          // Get row ID and check expansion state
          let mainRowId = mainRow.getAttribute("data-main-row-id");
          if (!mainRowId) return;

          // Update main row content
          const statusClass = this.getStatusClass(parsedData);

          // Create structured name cell
          const nameCell = document.createElement("td");

          // Add status indicator
          const statusSpan = document.createElement("span");
          statusSpan.className = `status-indicator ${statusClass}`;
          nameCell.appendChild(statusSpan);

          // Add name in strong tag with margin for expandable rows
          const nameStrong = document.createElement("strong");
          nameStrong.textContent = parsedData.name;
          nameCell.appendChild(nameStrong);

          // Create data cells with proper alignment
          const completedCell = document.createElement("td");
          completedCell.textContent = parsedData.completed;

          const rejectedCell = document.createElement("td");
          rejectedCell.textContent = parsedData.rejected;

          const inProcessCell = document.createElement("td");
          inProcessCell.textContent = parsedData.inProcess;

          const pendingCell = document.createElement("td");
          pendingCell.textContent = parsedData.pending;

          // Clear existing content and add structured cells
          mainRow.innerHTML = "";
          mainRow.appendChild(nameCell);
          mainRow.appendChild(completedCell);
          mainRow.appendChild(rejectedCell);
          mainRow.appendChild(inProcessCell);
          mainRow.appendChild(pendingCell);

          // Restore expand style if it exists
          if (mainRow.classList.contains("expandable")) {
            const isExpanded = this.expandedRows.has(mainRowId);
            if (isExpanded) {
              mainRow.classList.add("expanded");
            }
          }

          // Remove existing sub-rows
          const tableBody = document.querySelector("#sfTable tbody");
          const existingSubRows = tableBody.querySelectorAll(
            "[data-parent-id='" + mainRowId + "']"
          );
          existingSubRows.forEach((row) => row.remove());

          // Get old parsed data and merge with new
          let oldParsedData = mainRow.oldParsedData || { subProcesses: [] };

          // Log subProcesses from new response to ensure they are being handled
          console.log(
            `${step["Step Name"]} subProcesses:`,
            parsedData.subProcesses ? parsedData.subProcesses.length : 0
          );

          // Merge old and new subProcesses to preserve data during transitions
          let mergedSubProcesses = this.mergeSubProcesses(
            oldParsedData.subProcesses || [],
            parsedData.subProcesses || []
          );

          // Update old parsed data
          mainRow.oldParsedData = {
            ...parsedData,
            subProcesses: mergedSubProcesses,
          };

          // Get sub-steps and add them back
          let groupedSubSteps = mainRow.groupedSubSteps || [];
          if (groupedSubSteps.length > 0) {
            // Create virtual main step for addSubRows
            const virtualMain = {
              subSteps: groupedSubSteps,
            };

            // Add sub-rows with merged data
            this.addSubRows(
              tableBody,
              virtualMain,
              { ...parsedData, subProcesses: mergedSubProcesses },
              mainRowId
            );
          }
        },

        /**
         * Merge old and new sub-processes to preserve data during transitions
         * @param {Array} oldSubProcesses - Old sub-processes
         * @param {Array} newSubProcesses - New sub-processes
         * @returns {Array} Merged sub-processes
         */
        mergeSubProcesses: function (oldSubProcesses, newSubProcesses) {
          console.log(
            "Merging subprocesses:",
            "Old:",
            oldSubProcesses.length,
            "New:",
            newSubProcesses.length
          );

          // Create map of new sub-processes for quick lookup
          const mapNew = {};
          newSubProcesses.forEach((proc) => {
            mapNew[proc.name] = proc;
          });

          // Map old sub-processes, replacing with new if available
          const merged = oldSubProcesses.map((oldProc) =>
            mapNew[oldProc.name] ? mapNew[oldProc.name] : oldProc
          );

          // Add any new sub-processes not in old list
          newSubProcesses.forEach((newProc) => {
            if (!merged.some((m) => m.name === newProc.name)) {
              merged.push(newProc);
            }
          });

          console.log("Merged subprocesses count:", merged.length);
          return merged;
        },
      };
    </script>

    <!-- Diagram View Module -->
    <script>
      // Diagram View Module
      const DiagramView = {
        expandedMains: new Set(),
        nodeLookup: {},

        /**
         * Initialize diagram view
         */
        init: function () {
          this.setupTooltip();
          this.expandTopLevelNodes();
          this.buildDiagram();

          // Handle window resize
          window.addEventListener(
            "resize",
            Utils.debounce(() => {
              this.buildDiagram();
            }, 200)
          );
        },

        /**
         * Setup tooltip for diagram nodes
         */
        setupTooltip: function () {
          this.tooltip = document.getElementById("diagram-tooltip");
          const diagram = document.getElementById("diagram");

          diagram.addEventListener("mousemove", (e) => {
            // Position tooltip near mouse
            this.tooltip.style.left = e.pageX + 10 + "px";
            this.tooltip.style.top = e.pageY + 10 + "px";
          });
        },

        /**
         * Expand top level nodes on init
         */
        expandTopLevelNodes: function () {
          DataManager.steps.forEach((step) => {
            if (step.Type === "MAIN" && step["Parent Steps"].trim() === "0") {
              this.expandedMains.add(step["Step Number"]);
            }
          });
        },

        /**
         * Update diagram after data change
         * Enhanced to ensure proper updates
         */
        update: function () {
          console.log("Updating diagram with latest status data");

          // Clear any cached data that might prevent a proper update
          this.cachedData = null;

          // Fully rebuild the diagram
          this.buildDiagram();

          // Log update completion for debugging
          console.log("Diagram update complete");
        },

        /**
         * Get node status - improved function to get accurate status for any node
         * This is critical for proper diagram coloring
         *
         * @param {Object} node - Node to get status for
         * @returns {Object} Status object with status and counts
         */
        getNodeStatus: function (node) {
          // Default return value
          let result = {
            status: "unknown",
            completed: "0",
            rejected: "0",
            inProcess: "0",
            pending: "0",
          };

          // Case 1: Node has its own API
          if (node["API Name"] && DataManager.responses[node["API Name"]]) {
            const parsedData = DataManager.parseStatus(
              DataManager.responses[node["API Name"]]
            );
            if (parsedData) {
              console.log(
                `Direct API status for ${node["Step Name"]}:`,
                parsedData.status
              );
              return parsedData;
            }
          }

          // Case 2: For SUB nodes without API, check parent's subProcesses
          if (node.Type === "SUB" && node["Parent Steps"]) {
            const parentSteps = node["Parent Steps"]
              .split(",")
              .map((p) => p.trim());

            // Try each parent
            for (let parentId of parentSteps) {
              const parentNode = DataManager.getStepByNumber(parentId);
              if (!parentNode || !parentNode["API Name"]) continue;

              const parentResponse =
                DataManager.responses[parentNode["API Name"]];
              if (!parentResponse) continue;

              const parsedParent = DataManager.parseStatus(parentResponse);
              if (
                !parsedParent ||
                !parsedParent.subProcesses ||
                !parsedParent.subProcesses.length
              )
                continue;

              // Find this node in parent's subProcesses
              const subProcess = parsedParent.subProcesses.find(
                (sp) =>
                  sp.name &&
                  sp.name.toLowerCase() === node["Step Name"].toLowerCase()
              );

              if (subProcess) {
                console.log(
                  `Found subprocess ${node["Step Name"]} in parent ${parentNode["Step Name"]} with status: ${subProcess.status}`
                );
                return {
                  status: subProcess.status || "unknown",
                  completed: subProcess.completed || "0",
                  rejected: subProcess.rejected || "0",
                  inProcess: subProcess.inProcess || "0",
                  pending: subProcess.pending || "0",
                };
              }
            }
          }

          return result;
        },

        /**
         * Get visible nodes based on expanded state
         * @returns {Array} Array of visible nodes
         */
        getVisibleNodes: function () {
          const mainNodes = DataManager.steps.filter((d) => d.Type === "MAIN");
          const subNodes = DataManager.steps.filter((d) => d.Type === "SUB");
          const visibleSubs = [];

          subNodes.forEach((sub) => {
            if (!sub["Parent Steps"]) return;

            const parents = sub["Parent Steps"].split(",").map((p) => p.trim());

            for (let pid of parents) {
              if (this.expandedMains.has(pid)) {
                visibleSubs.push(sub);
                break;
              }
            }
          });

          return [...mainNodes, ...visibleSubs];
        },

        /**
         * Build SVG diagram
         */
        buildDiagram: function () {
          const svg = document.getElementById("diagram");

          // Clear SVG
          while (svg.firstChild) {
            svg.removeChild(svg.firstChild);
          }

          // Reset node lookup
          this.nodeLookup = {};

          // Get visible nodes
          const visibleNodes = this.getVisibleNodes();

          // Compute layout
          this.computeLayout(visibleNodes);

          // Create node map for quick lookup
          const mapVisible = {};
          visibleNodes.forEach((d) => {
            mapVisible[d["Step Number"]] = d;
          });

          // Get SVG dimensions
          const SVG_WIDTH = svg.clientWidth;
          const SVG_HEIGHT = svg.clientHeight;

          // Create arrow marker definition
          const defs = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "defs"
          );
          const marker = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "marker"
          );
          marker.setAttribute("id", "arrow");
          marker.setAttribute("viewBox", "0 0 10 10");
          marker.setAttribute("refX", "10");
          marker.setAttribute("refY", "5");
          marker.setAttribute("markerWidth", "6");
          marker.setAttribute("markerHeight", "6");
          marker.setAttribute("orient", "auto-start-reverse");

          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
          path.setAttribute("fill", "#555");

          marker.appendChild(path);
          defs.appendChild(marker);
          svg.appendChild(defs);

          // Draw edges first (to appear behind nodes)
          this.drawEdges(svg, visibleNodes, mapVisible);

          // Draw nodes
          this.drawNodes(svg, visibleNodes);
        },

        /**
         * Compute layout for diagram nodes
         * @param {Array} visibleData - Array of visible nodes
         */
        computeLayout: function (visibleData) {
          const svg = document.getElementById("diagram");
          const SVG_WIDTH = svg.clientWidth;
          const SVG_HEIGHT = svg.clientHeight;

          // Layout constants
          const NODE_WIDTH = 120;
          const NODE_HEIGHT = 40;
          const LEVEL_VERTICAL_SPACING = 100;
          const MARGIN_X = 50;
          const SUB_EXTRA_SPACE = 50;

          // Create node map and initialize levels
          const nodesMap = {};
          visibleData.forEach((d) => {
            d.level = d["Parent Steps"].trim() === "0" ? 0 : undefined;
            nodesMap[d["Step Number"]] = d;
          });

          // Calculate levels with topological sort
          let changed = true;
          while (changed) {
            changed = false;
            visibleData.forEach((item) => {
              if (item["Parent Steps"].trim() !== "0") {
                const parents = item["Parent Steps"]
                  .split(",")
                  .map((s) => s.trim());

                let maxParentLevel = -1;
                parents.forEach((pid) => {
                  const parent = nodesMap[pid];
                  if (
                    parent &&
                    parent.level !== undefined &&
                    parent.level > maxParentLevel
                  ) {
                    maxParentLevel = parent.level;
                  }
                });

                const newLevel = maxParentLevel + 1;
                if (item.level === undefined || newLevel > item.level) {
                  item.level = newLevel;
                  changed = true;
                }
              }
            });
          }

          // Group nodes by level
          const levelsMap = {};
          visibleData.forEach((item) => {
            if (!levelsMap[item.level]) {
              levelsMap[item.level] = [];
            }
            levelsMap[item.level].push(item);
          });

          // Calculate positions
          const baseY = 50;
          const offsets = {};
          offsets[0] = 0;

          // Sort levels
          const levelsSorted = Object.keys(levelsMap)
            .map(Number)
            .sort((a, b) => a - b);

          // Position nodes by level
          levelsSorted.forEach((level) => {
            const nodesAtLevel = levelsMap[level];
            const count = nodesAtLevel.length;

            // Distribute nodes horizontally
            const spacingX = Math.max(
              NODE_WIDTH + 20,
              (SVG_WIDTH - 2 * MARGIN_X) / (count + 1)
            );

            // Position nodes
            nodesAtLevel.forEach((node, i) => {
              node.x = MARGIN_X + spacingX * (i + 1) - NODE_WIDTH / 2;
              node.y =
                baseY + level * LEVEL_VERTICAL_SPACING + (offsets[level] || 0);

              // Store node in lookup
              this.nodeLookup[node["Step Number"]] = {
                x: node.x,
                y: node.y,
                width: NODE_WIDTH,
                height: NODE_HEIGHT,
              };
            });

            // Calculate extra space for expanded nodes
            let extra = 0;
            nodesAtLevel.forEach((node) => {
              if (
                node.Type === "MAIN" &&
                this.expandedMains.has(node["Step Number"])
              ) {
                const subCount = visibleData.filter((d) => {
                  if (d.Type === "SUB") {
                    if (!d["Parent Steps"]) return false;
                    const parents = d["Parent Steps"]
                      .split(",")
                      .map((s) => s.trim());
                    return parents.includes(node["Step Number"]);
                  }
                  return false;
                }).length;

                if (subCount > 0) {
                  extra = Math.max(extra, subCount * SUB_EXTRA_SPACE);
                }
              }
            });

            // Set offset for next level
            offsets[level + 1] = (offsets[level] || 0) + extra;
          });
        },

        /**
         * Draw edges between nodes
         * @param {SVGElement} svg - SVG element
         * @param {Array} visibleNodes - Array of visible nodes
         * @param {Object} mapVisible - Map of visible nodes
         */
        drawEdges: function (svg, visibleNodes, mapVisible) {
          // Node dimensions
          const NODE_WIDTH = 120;
          const NODE_HEIGHT = 40;

          visibleNodes.forEach((child) => {
            if (!child["Parent Steps"] || child["Parent Steps"].trim() === "0")
              return;

            const parents = child["Parent Steps"]
              .split(",")
              .map((s) => s.trim());

            parents.forEach((pid) => {
              const parent = mapVisible[pid];
              if (!parent) return;

              // Calculate path
              const startX = parent.x + NODE_WIDTH / 2;
              const startY = parent.y + NODE_HEIGHT;
              const endX = child.x + NODE_WIDTH / 2;
              const endY = child.y;

              // Create bezier curve for smoother edges
              const controlPoint1X = startX;
              const controlPoint1Y = startY + (endY - startY) / 3;
              const controlPoint2X = endX;
              const controlPoint2Y = endY - (endY - startY) / 3;

              // Create path
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
              );

              line.setAttribute(
                "d",
                `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`
              );
              line.setAttribute("class", "edge");
              line.setAttribute("fill", "none");

              svg.appendChild(line);
            });
          });
        },

        /**
         * Draw nodes - IMPROVED to use proper status lookup
         * @param {SVGElement} svg - SVG element
         * @param {Array} visibleNodes - Array of visible nodes
         */
        drawNodes: function (svg, visibleNodes) {
          // Node dimensions
          const NODE_WIDTH = 120;
          const NODE_HEIGHT = 40;

          visibleNodes.forEach((node) => {
            // Create node group
            const g = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            g.setAttribute("class", "node");
            g.setAttribute("id", "node-" + node["Step Number"]);

            // Create node rectangle
            const rect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            rect.setAttribute("x", node.x);
            rect.setAttribute("y", node.y);
            rect.setAttribute("width", NODE_WIDTH);
            rect.setAttribute("height", NODE_HEIGHT);
            rect.setAttribute("rx", "10");
            rect.setAttribute("ry", "10");

            // Set default node style
            let fillColor = "#808080"; // Default gray
            let strokeWidth = "4";
            let strokeColor = "#606060";
            let strokeDashArray = "none";

            // Use our improved helper function to get accurate status
            const parsedStatus = this.getNodeStatus(node);

            console.log(
              `Drawing node: ${node["Step Name"]}, Status: ${parsedStatus.status}`
            );

            if (parsedStatus) {
              // Determine color based on direct status field
              const status = parsedStatus.status
                ? parsedStatus.status.toLowerCase()
                : "";

              // Color mapping according to requirements
              if (status === "n/a") {
                fillColor = "#000000"; // Black for N/A
                strokeColor = "#333333";
              } else if (status === "failed" || status === "rejected") {
                fillColor = "#e74c3c"; // Red for failed/rejected
                strokeColor = "#c0392b";
              } else if (status === "running" || status === "in process") {
                fillColor = "#2ecc71"; // Green for running/in-process
                strokeColor = "#27ae60";
                strokeDashArray = "5, 5"; // Dashed for in-process
              } else if (status === "completed") {
                fillColor = "#2ecc71"; // Green for completed
                strokeColor = "#27ae60";
              } else if (status === "pending") {
                fillColor = "#ffffff"; // White for pending
                strokeColor = "#999999";
              } else {
                fillColor = "#808080"; // Gray for rest/default
                strokeColor = "#606060";
              }
            }

            // Apply styles to rectangle
            rect.setAttribute("fill", fillColor);
            rect.setAttribute("stroke", strokeColor);
            rect.setAttribute("stroke-width", strokeWidth);
            if (strokeDashArray !== "none") {
              rect.setAttribute("stroke-dasharray", strokeDashArray);
            }

            g.appendChild(rect);

            // Create node text
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            text.setAttribute("x", node.x + NODE_WIDTH / 2);
            text.setAttribute("y", node.y + NODE_HEIGHT / 2 + 5);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("font-size", "12");

            // Set text color based on background for readability
            if (fillColor === "#ffffff" || fillColor === "#f2f2f2") {
              text.setAttribute("fill", "#333333");
            } else {
              text.setAttribute("fill", "#ffffff");
            }

            // Truncate long text
            let stepName = node["Step Name"] || "";
            if (stepName.length > 15) {
              stepName = stepName.substring(0, 12) + "...";
            }

            text.textContent = stepName;
            g.appendChild(text);

            // Add event listeners
            if (node.Type === "MAIN") {
              // Click to expand/collapse
              g.addEventListener("click", (e) => {
                e.stopPropagation();
                this.toggleMainExpand(node["Step Number"]);
              });

              // Mouse over to show tooltip
              g.addEventListener("mouseenter", () => {
                this.showNodeTooltip(node);
              });

              g.addEventListener("mouseleave", () => {
                this.hideNodeTooltip();
              });
            } else {
              // Mouse over to show tooltip for sub nodes
              g.addEventListener("mouseenter", () => {
                this.showNodeTooltip(node);
              });

              g.addEventListener("mouseleave", () => {
                this.hideNodeTooltip();
              });
            }

            svg.appendChild(g);
          });
        },

        /**
         * Show tooltip for node - IMPROVED to show accurate status
         * @param {Object} node - Node data
         */
        showNodeTooltip: function (node) {
          if (!this.tooltip) return;

          // Get the most accurate status data for this node
          const nodeStatus = this.getNodeStatus(node);

          let tooltipContent = `<strong>${node["Step Name"]}</strong><br>Type: ${node.Type}`;

          // If node has an API, show it
          if (node["API Name"]) {
            tooltipContent += `<br>API: ${node["API Name"]}`;
          }

          // Add status information
          tooltipContent += `<br>Status: <b>${nodeStatus.status}</b>`;
          tooltipContent += `<br>Completed: ${nodeStatus.completed}`;
          tooltipContent += `<br>Rejected: ${nodeStatus.rejected}`;
          tooltipContent += `<br>In Process: ${nodeStatus.inProcess}`;
          tooltipContent += `<br>Pending: ${nodeStatus.pending}`;

          this.tooltip.innerHTML = tooltipContent;
          this.tooltip.style.opacity = "1";
        },

        /**
         * Hide node tooltip
         */
        hideNodeTooltip: function () {
          if (!this.tooltip) return;
          this.tooltip.style.opacity = "0";
        },

        /**
         * Toggle expansion of main node
         * @param {string} mainId - Main node ID
         */
        toggleMainExpand: function (mainId) {
          if (this.expandedMains.has(mainId)) {
            this.expandedMains.delete(mainId);
          } else {
            this.expandedMains.add(mainId);
          }
          this.buildDiagram();
        },
      };
    </script>
  </body>
</html>
